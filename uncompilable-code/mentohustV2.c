/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2011 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Data declarations

extern _UNKNOWN start; // weak
extern char modes[3]; // idb
extern _UNKNOWN unk_804E523; // weak
extern char aSS[7]; // weak
extern char aRb[]; // idb
extern char s2[]; // idb
extern char src[]; // idb
extern char byte_804E555[]; // weak
extern char name[]; // idb
extern char file[]; // idb
extern char aLibnotify_so_1[]; // idb
extern char msgid[]; // idb
extern char aNotify_init[]; // idb
extern char aNotify_notific[]; // idb
extern char aNotify_notif_0[]; // idb
extern char aNotify_notif_1[]; // idb
extern char aNotify_notif_2[]; // idb
extern char aFOlibnotifysoX[]; // idb
extern char aMentohust[10]; // weak
extern char aMentohust_0[10]; // weak
extern char aXiaxzlxmclibno[]; // idb
extern char aCiuxAlibpcapxd[]; // idb
extern char aPcap_findallde[]; // idb
extern char aPcap_freeallde[]; // idb
extern char aPcap_open_live[]; // idb
extern char aPcap_compile[]; // idb
extern char aPcap_setfilter[]; // idb
extern char aPcap_geterr[]; // idb
extern char aPcap_freecode[]; // idb
extern char aPcap_loop[]; // idb
extern char aPcap_close[]; // idb
extern char aPcap_breakloop[]; // idb
extern char aPcap_sendpacke[]; // idb
extern char aFOlibpcapsoXpc[]; // idb
extern char *off_804E7F0[5]; // weak
extern char aXxghlmxhzb[11]; // weak
extern char aCiasaicczfScca[]; // idb
extern char a02x[6]; // weak
extern char aXovciClpciicMD[]; // idb
extern char aMd5cznxnrS[]; // idb
extern char aCXS8021x_exefB[]; // idb
extern char aV2cabskmxaS[]; // idb
extern char aD_D_D_D[12]; // weak
extern char aXiixXeccoexncx[]; // idb
extern char aXIcSxnbSfKsoXp[]; // idb
extern char aXIcSxnbSfKso_0[]; // idb
extern char aCMcMacS[]; // idb
extern char aFCfiipS[]; // idb
extern char aXnrcScoicabS[]; // idb
extern char aXIcSxnbSfKso_1[]; // idb
extern char fromcode[]; // idb
extern char tocode[]; // idb
extern char aCmzxoCDsuconfi[]; // idb
extern char aPingfCXzSfsqMx[]; // idb
extern int dword_804EA04; // weak
extern int dword_804EA08; // weak
extern int dword_804EA0C; // weak
extern int dword_804EA10; // weak
extern _UNKNOWN unk_804EA14; // weak
extern _UNKNOWN unk_804EA54; // weak
extern _UNKNOWN unk_804EC14; // weak
extern _UNKNOWN unk_804EC74; // weak
extern char *off_804EE74; // idb
extern char aCiFNxiCNxkbxsi[39]; // weak
extern char aXpssabcficiXrn[]; // idb
extern char aXpssabxpjcabsE[39]; // weak
extern char aCnixasxunxFxme[]; // idb
extern char aCngxIsoXpcip__[]; // idb
extern char aCunfCUcaquav[]; // idb
extern char aXpCiCNxkbxsi__[]; // idb
extern char aXpssabcficiX_0[]; // idb
extern char aXpssabxpjcab__[]; // idb
extern char aSodspbcoicQMxA[]; // idb
extern char aXpssabxGsXmefE[]; // idb
extern _UNKNOWN unk_804EFEC; // weak
extern char aSoXpccIclpxUca[]; // idb
extern char aSoCOcIclpxUcaz[]; // idb
extern char aCqeciCSxnbxdSE[]; // idb
extern char aAny[]; // idb
extern char aCSxnbDS[]; // idb
extern char aCiFNxiCSxnbqB[]; // idb
extern char a__SpSaiclicSxn[]; // idb
extern char aCvisaiclifJcmm[]; // idb
extern char aDhcpscript[11]; // weak
extern char aDatafile[9]; // weak
extern char aU_U[6]; // weak
extern char aVersion[8]; // weak
extern char a0_00[]; // idb
extern char aShownotify[11]; // weak
extern char aDaemonmode[11]; // weak
extern char aDhcpmode[9]; // weak
extern char aStartmode[10]; // weak
extern char aMaxfail[8]; // weak
extern char aRestartwait[12]; // weak
extern char aEchointerval[13]; // weak
extern char aTimeout[8]; // weak
extern char aPinghost[9]; // weak
extern char aDns[4]; // weak
extern char aGateway[8]; // weak
extern char aMask[5]; // weak
extern char aIp[3]; // weak
extern char aNic[4]; // weak
extern char aPassword[9]; // weak
extern char aUsername[9]; // weak
extern char aFAxnssodspbxpv[37]; // weak
extern char aSodspbxpvcxXCi[]; // idb
extern char aDatafile_0[9]; // weak
extern char a255_255_255_25[]; // idb
extern char a0_0_0_0[]; // idb
extern char aCmvsOfCfimento[]; // idb
extern char aHttpCode_googl[47]; // weak
extern char a0_3_1[6]; // weak
extern char aHelp[]; // idb
extern char aCficXSSaisbXpv[]; // idb
extern char aSXeelibpcapxdS[46]; // weak
extern char aMentohustSfssp[]; // idb
extern char aCiFNxiCSxnbq_0[19]; // weak
extern char a__SpSUxeecfici[]; // idb
extern char a__SpSUxeexpjca[]; // idb
extern char a__SpSaiclicDct[]; // idb
extern char a__SpSaiclidhcp[]; // idb
extern char aCiuxAsfbcczfXd[25]; // weak
extern char aSoXpccczfSfbxd[25]; // weak
extern char aXXpssabsaaxzFB[]; // idb
extern char aCUcaqsIcilxdSE[]; // idb
extern char aCBcImentohustc[]; // idb
extern char aMentohustxCPsR[]; // idb
extern char aSIxeexroxpSRsb[]; // idb
extern char aXroxpSRsbmxdSE[]; // idb
extern char aA[]; // idb
extern char aXkasfbxdSE[]; // idb
extern char aCunfSfbcczfXdS[56]; // weak
extern char aCazxzj[]; // idb
extern char aSfrcn[]; // idb
extern char aSIxF[]; // idb
extern char aFNfCfi[]; // idb
extern char aFMcmbsodspb[]; // idb
extern char aSodspbxro[]; // idb
extern char aSodspbxin[]; // idb
extern char aCficiXrnS[]; // idb
extern char aCSxnbS[]; // idb
extern char aCSxeXXaaS[]; // idb
extern char aDnsxXaaS[]; // idb
extern char aCsSgSznsUS[]; // idb
extern char aSodspbsEccUczt[]; // idb
extern char aXGsScSFUczt[]; // idb
extern char aXdSEcnixEUczt[]; // idb
extern char aXebsoXdSEUcmb[]; // idb
extern char aCDctnxXaaS[]; // idb
extern char aDhcpccXPS[]; // idb
extern char aSaCqesEccDczt[]; // idb
extern char aCxCnocczfS[]; // idb
extern char aDhcpsdCMS[]; // idb
extern char aSoXpcmacxXaaci[]; // idb
extern char *off_804FC50[2]; // weak
extern char *filename; // idb
extern char byte_804FC58[]; // weak
extern char byte_804FC9C[]; // weak
extern char *off_804FCE8; // idb
extern char *off_804FCEC; // idb
extern char aXpssabcxCnoxme[]; // idb
extern char aXpssabcxCnox_0[]; // idb
extern char aCCQcprcdS[]; // idb
extern char aMentohustCCQcp[]; // idb
extern char aSobsCprcdS[]; // idb
extern char aMentohustSobsC[]; // idb
extern char aSodspbmacS[]; // idb
extern char aUserName[10]; // weak
extern char aSodspbcirxkq[]; // idb
extern char aSodspbxdSE[]; // idb
extern char aSUcNsodspbxdSE[]; // idb
extern char aCSxeMacS[]; // idb
extern char aArpSSS[13]; // weak
extern char aArpcmSkcS[]; // idb
extern char aCmSkccRS[]; // idb
extern char aMentohustArpcp[]; // idb
extern char aSodspbxSaaxzUa[]; // idb
extern int dword_8050F00; // weak
extern int dword_8050F08[]; // weak
extern _UNKNOWN unk_8050F0C; // weak
extern int dword_8050F10; // weak
extern _UNKNOWN unk_80510F0; // weak
extern _UNKNOWN unk_80510F4; // weak
extern int dword_8051134; // weak
extern char byte_8051138; // idb
extern FILE stream; // idb
extern char domainname; // idb
extern int dword_80513D0; // weak
extern int dword_80513D4; // weak
extern int dword_80513D8; // weak
extern int dword_80513DC; // weak
extern int fd; // idb
extern FILE *stderr; // idb
extern FILE *stdout; // idb
extern char byte_8051424; // weak
extern int dword_8051428; // weak
extern _UNKNOWN unk_805142C; // weak
extern void *ptr; // idb
extern size_t size; // idb
extern _DWORD dword_8051444; // idb
extern void *handle; // idb
extern void *dword_805144C; // idb
extern int (__cdecl *dword_8051450)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
extern int (__cdecl *dword_8051454)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
extern int (__stdcall *dword_8051458)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
extern size_t dword_805145C; // idb
extern size_t dword_8051460; // idb
extern int dword_8051464; // weak
extern int dword_8051468; // weak
extern int dword_805146C; // weak
extern int dword_8051470; // weak
extern _UNKNOWN unk_8051474; // weak
extern _UNKNOWN unk_80515F8; // weak
extern int dword_8051608; // weak
extern int dword_805160C; // weak
extern int dword_8051610; // weak
extern _UNKNOWN dword_8051614; // weak
extern int dword_8051618; // weak
extern __int16 word_805161C; // weak
extern int dword_805161E; // weak
extern __int16 word_8051622; // weak
extern int dword_8051624; // weak
extern __int16 word_8051628; // weak
extern char byte_805162A; // weak
extern char byte_805162B; // weak
extern __int16 word_805162C; // weak
extern char byte_805162E[]; // weak
extern char byte_805162F; // weak
extern _UNKNOWN unk_8051630; // weak
extern _UNKNOWN unk_805163F; // weak
extern int dword_8051640; // weak
extern int dword_8051644; // weak
extern _UNKNOWN unk_8051648; // weak
extern int dword_8051A00; // weak
extern int dword_8051A04; // weak
extern int dword_8051A08; // weak
extern int dword_8051A0C; // weak
extern int dword_8051A10; // weak
extern int dword_8051A14; // weak
extern int dword_8051A18; // weak
extern int status; // idb
extern int dword_8051A20; // weak
extern int (__cdecl *dword_8051A24)(_DWORD, _DWORD); // weak
extern int (__cdecl *dword_8051A28)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
extern int (__cdecl *dword_8051A2C)(_DWORD); // weak
extern int dword_8051A30; // weak
extern int dword_8051A34; // weak
extern int dword_8051A38; // weak
extern int (__cdecl *dword_8051A3C)(_DWORD); // weak
extern int (__cdecl *dword_8051A40)(_DWORD); // weak
extern int dword_8051A44; // weak
extern int dword_8051A48; // weak
extern int dword_8051A4C; // weak
extern __int16 word_8051A50; // weak
extern int dword_8051A54; // weak
extern __int16 word_8051A58; // weak
extern int dword_8051A5C; // weak
extern __int16 word_8051A60; // weak
extern int dword_8051A64; // weak
extern __int16 word_8051A68; // weak
// extern _UNKNOWN _gmon_start__; weak

//-------------------------------------------------------------------------
// Function declarations

int __cdecl init_proc();
// int open(const char *file, int oflag, ...);
// __pid_t getpid(void);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// int daemon(int nochdir, int noclose);
// int memcmp(const void *s1, const void *s2, size_t n);
// int __gmon_start__(void); weak
// iconv_t iconv_open(const char *tocode, const char *fromcode);
// void rewind(FILE *stream);
// int __isoc99_sscanf(_DWORD, const char *, ...); weak
// int __printf_chk(_DWORD, const char *, ...); weak
// in_addr_t inet_addr(const char *cp);
// int system(const char *command);
// char *strncpy(char *dest, const char *src, size_t n);
// ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len);
// int dlclose(void *handle);
// int setitimer(__itimer_which_t which, const struct itimerval *new, struct itimerval *old);
// int __cdecl __memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD); weak
// char *strrchr(const char *s, int c);
// int tcgetattr(int fd, struct termios *termios_p);
// void perror(const char *s);
// void free(void *ptr);
// char *dcgettext(const char *domainname, const char *msgid, int category);
// void *dlsym(void *handle, const char *name);
// int ioctl(int fd, unsigned __int32 request, ...);
// int socket(int domain, int type, int protocol);
// int fseek(FILE *stream, __int32 off, int whence);
// int fclose(FILE *stream);
// FILE *fopen(const char *filename, const char *modes);
// size_t iconv(iconv_t cd, char **inbuf, size_t *inbytesleft, char **outbuf, size_t *outbytesleft);
// FILE *freopen(const char *filename, const char *modes, FILE *stream);
// char *strcpy(char *dest, const char *src);
// void *dlopen(const char *file, int mode);
// __int32 ftell(FILE *stream);
// __uid_t getuid(void);
// int atoi(const char *nptr);
// int __cdecl __strcpy_chk(_DWORD, _DWORD, _DWORD); weak
// int close(int fd);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int setvbuf(FILE *stream, char *buf, int modes, size_t n);
// void *malloc(size_t size);
// int __fastcall __stack_chk_fail(_DWORD); weak
// int iconv_close(iconv_t cd);
// char *dlerror(void);
// int poll(struct pollfd *fds, nfds_t nfds, int timeout);
// int __isoc99_scanf(const char *, ...); weak
// int strncasecmp(const char *s1, const char *s2, size_t n);
// void *memmove(void *dest, const void *src, size_t n);
// int tcsetattr(int fd, int optional_actions, const struct termios *termios_p);
// int fcntl(int fd, int cmd, ...);
// int __sprintf_chk(_DWORD, _DWORD, _DWORD, const char *, ...); weak
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int seteuid(__uid_t uid);
// int kill(__pid_t pid, int sig);
// int strcmp(const char *s1, const char *s2);
// void exit(int status);
void __cdecl sub_8049100();
int __cdecl sub_8049160();
int __cdecl sub_8049184(const void *stream, const char *filename);
// signed int __usercall sub_80491D9<eax>(int a1<eax>, const char *a2<edx>, const char *a3<ecx>, int a4, int a5, int a6);
void __cdecl sub_80492EF(int *a1, const char *a2, const char *a3, const char *src);
int __cdecl sub_80495DC(int *a1, const char *a2, const char *a3, int a4);
signed int __cdecl sub_804963C(int a1, const char *a2, const char *a3, const char *src, char *dest, size_t n);
int __cdecl sub_80496B3(int a1, const char *a2, const char *a3, int a4);
__int32 __cdecl sub_804971D(void **a1, const char *filename);
// int __usercall sub_80497D9<eax>(int a1<eax>, int a2<edx>);
unsigned int __cdecl sub_8049F3B(int a1, const void *a2, unsigned int a3);
int __cdecl sub_8049FCF(int a1, int a2);
_UNKNOWN *__cdecl sub_804A0A5(const void *a1, unsigned int a2);
void __cdecl sub_804A166();
signed int __cdecl sub_804A18D(const char *filename);
int __cdecl sub_804A30D(const void *a1, int a2);
// int __usercall sub_804A46D<eax>(unsigned __int8 *a1<eax>, unsigned int a2<edx>, unsigned int a3<ecx>, int a4);
signed int __cdecl sub_804A58B(const char *filename, unsigned int a2, int a3);
signed int __cdecl sub_804A5CA(const char *a1);
char *__cdecl sub_804A800();
signed int __cdecl sub_804A865(int a1, int a2, int a3);
char *__cdecl sub_804AA78();
signed int __cdecl sub_804AAA4();
// int __usercall sub_804ACF0<eax>(int a1<eax>);
int __cdecl sub_804AD88(int a1);
int __cdecl sub_804ADE0(int a1);
int __cdecl sub_804AE79(int a1);
// signed int __usercall sub_804AEA3<eax>(char a1<al>, const void *a2<edx>, unsigned int a3<ecx>);
_UNKNOWN *__cdecl sub_804AEFB(char a1, const void *a2, unsigned int a3);
// signed int __usercall sub_804AFA5<eax>(signed int a1<eax>);
int __cdecl sub_804B0FE();
int sub_804B1E7(void); // weak
int __cdecl sub_804B28D();
_UNKNOWN *__cdecl sub_804B3FF(int a1, signed int a2);
// signed int __usercall sub_804B45D<eax>(int a1<eax>);
_DWORD __cdecl sub_804B557(_DWORD); // weak
_UNKNOWN *__cdecl sub_804B5AB(int a1);
// signed int __usercall sub_804B5DF<eax>(int a1<edi>, int a2<esi>);
char *__cdecl sub_804B8C6(char *inbuf, size_t inbytesleft);
int __cdecl sub_804B950(const char *filename);
signed int __fastcall sub_804B9EB(int a1);
// int __usercall sub_804BB0C<eax>(__time_t a1<eax>);
int __cdecl sub_804BB38();
// __int16 __usercall sub_804BB72<ax>(unsigned int a1<eax>);
// int __usercall sub_804BBC1<eax>(int a1<ecx>, int *a2<ebx>, int a3<edi>, signed int a4);
int sub_804C3BC(void); // weak
bool __cdecl sub_804C4D5(int a1);
// signed int __usercall sub_804C5B1<eax>(int a1<ebx>);
// signed int __usercall sub_804C762<eax>(int a1<eax>);
// int __usercall sub_804C890<eax>(int a1<eax>);
// signed int __usercall sub_804CB6A<eax>(int a1<eax>);
// int __usercall sub_804D02F<eax>(int a1<ebx>, char a2, int a3);
// int __usercall sub_804DC40<eax>(int a1<ecx>, int *a2<ebx>, int a3<edi>, int a4);
// void __usercall sub_804DD0B(int a1<eax>, unsigned int a2<edx>);
int __fastcall sub_804DE92(int a1, int a2, int a3, int a4, int a5);
// int __usercall sub_804E38E<eax>(int a1<ecx>, int *a2<ebx>, int a3<edi>);
void __cdecl sub_804E420();
int *__cdecl sub_804E430();
void __cdecl sub_804E48A();
int __cdecl sub_804E490(int a1);
void (*__cdecl sub_804E4D0())(void);
void __cdecl term_proc();


//----- (08048CDC) --------------------------------------------------------
int __cdecl init_proc()
{
  int v1; // [sp+0h] [bp-8h]@0

  if ( &_gmon_start__ )
    __gmon_start__();
  sub_8049160();
  sub_804E4D0();
  return v1;
}
// 8048D7C: using guessed type int __gmon_start__(void);

//----- (080490D0) --------------------------------------------------------
#error "80490D3: positive sp value has been found (funcsize=2)"

//----- (08049100) --------------------------------------------------------
void __cdecl sub_8049100()
{
  int v0; // eax@2
  int i; // ebx@2

  if ( !byte_8051424 )
  {
    v0 = dword_8051428;
    for ( i = ((signed int)(&unk_8050F0C - (_UNKNOWN *)dword_8050F08) >> 2) - 1;
          dword_8051428 < (unsigned int)i;
          v0 = dword_8051428 )
    {
      dword_8051428 = v0 + 1;
      ((void (*)(void))dword_8050F08[v0 + 1])();
    }
    byte_8051424 = 1;
  }
}
// 8050F08: using guessed type int dword_8050F08[];
// 8051424: using guessed type char byte_8051424;
// 8051428: using guessed type int dword_8051428;

//----- (08049160) --------------------------------------------------------
int __cdecl sub_8049160()
{
  int result; // eax@1

  result = dword_8050F10;
  if ( dword_8050F10 )
    result = 0;
  return result;
}
// 8050F10: using guessed type int dword_8050F10;

//----- (08049184) --------------------------------------------------------
int __cdecl sub_8049184(const void *stream, const char *filename)
{
  int v2; // edi@1
  FILE *v3; // ebx@1

  v2 = -1;
  v3 = fopen(filename, "wb");
  if ( v3 )
  {
    v2 = -(fwrite(stream, strlen((const char *)stream), 1u, v3) < 1);
    fclose(v3);
  }
  return v2;
}

//----- (080491D9) --------------------------------------------------------
signed int __usercall sub_80491D9<eax>(int a1<eax>, const char *a2<edx>, const char *a3<ecx>, int a4, int a5, int a6)
{
  int v6; // esi@1
  int v7; // ebx@1
  const char *v8; // ecx@2
  const char v9; // al@3
  int v10; // edi@7
  char v11; // dl@9
  int v12; // edi@13
  int i; // eax@13
  char v14; // dl@16
  int v15; // edi@25
  int v16; // eax@25
  char v17; // dl@28
  int v18; // edi@31
  int v20; // [sp+Ch] [bp-2Ch]@7
  const char *s2; // [sp+14h] [bp-24h]@1
  const char *v22; // [sp+18h] [bp-20h]@1

  v6 = 0;
  v7 = a1;
  s2 = a2;
  v22 = a3;
  *(_DWORD *)a4 = -1;
LABEL_32:
  while ( 1 )
  {
    v8 = (const char *)(v7 + v6);
    if ( !*(_BYTE *)(v7 + v6) )
      return -1;
    while ( 1 )
    {
      v9 = *v8;
      if ( *v8 != 9 )
      {
        if ( v9 != 32 && v9 != 13 && v9 != 10 )
          break;
      }
      ++v6;
      ++v8;
    }
    v10 = v7 + v6;
    v20 = v6;
    while ( 1 )
    {
      v11 = *(_BYTE *)v10;
      if ( *(_BYTE *)v10 == 10 )
        break;
      if ( v11 == 13 )
        break;
      ++v10;
      if ( !v11 )
        break;
      ++v6;
    }
    if ( v9 == 91 )
    {
      v12 = v7 + v20;
      for ( i = v20 + 1; i < v6; ++i )
      {
        v14 = *(_BYTE *)(v12++ + 1);
        if ( v14 == 93 )
        {
          if ( !strncasecmp((const char *)(v7 + v20 + 1), s2, i - (v20 + 1)) )
          {
            *(_DWORD *)a4 = v20;
            if ( v22 )
              goto LABEL_32;
            return -1;
          }
          break;
        }
      }
      if ( *(_DWORD *)a4 == -1 )
        continue;
      return -1;
    }
    if ( *(_DWORD *)a4 != -1 && v9 != 35 && v9 != 59 )
    {
      v15 = v20 + 1;
      v16 = v7 + v20;
      while ( v15 < v6 )
      {
        v17 = *(_BYTE *)(v16++ + 1);
        if ( v17 == 61 )
          break;
        ++v15;
      }
      if ( v15 < v6 && !strncasecmp(v8, v22, v15 - v20) )
      {
        v18 = v15 + 1;
        *(_DWORD *)a5 = v18;
        *(_DWORD *)a6 = v6 - v18;
        return 0;
      }
    }
  }
}

//----- (080492EF) --------------------------------------------------------
void __cdecl sub_80492EF(int *a1, const char *a2, const char *a3, const char *src)
{
  signed int v4; // eax@1
  int v5; // edx@2
  int v6; // edi@3
  signed int v7; // ecx@3
  char v8; // zf@5
  const char *v9; // edi@6
  signed int v10; // esi@6
  signed int v11; // ecx@6
  void *v12; // ST2C_4@10
  int v13; // ebx@13
  int i; // edx@13
  int v15; // ecx@14
  int v16; // esi@19
  int v17; // ecx@19
  signed int v18; // edi@19
  char v19; // al@21
  int v20; // esi@25
  int v21; // edi@25
  char v22; // dl@28
  signed int v23; // edx@29
  int v24; // edi@38
  signed int v25; // ecx@38
  const char *v26; // edi@41
  signed int v27; // edx@41
  signed int v28; // ecx@41
  void *v29; // eax@44
  const char *v30; // edi@44
  signed int v31; // ecx@44
  int v32; // esi@44
  int v33; // edi@50
  int v34; // ecx@50
  const char *v35; // edi@53
  int v36; // ecx@53
  const char *v37; // edi@56
  int v38; // edx@56
  int v39; // ecx@56
  int v40; // edx@56
  const char *v41; // edi@59
  int v42; // esi@59
  int v43; // ecx@59
  void *v44; // esi@62
  void *v45; // edi@62
  int v46; // ecx@62
  int v47; // [sp-Ch] [bp-48h]@9
  int v48; // [sp-8h] [bp-44h]@9
  size_t v49; // [sp-4h] [bp-40h]@9
  int v50; // [sp+8h] [bp-34h]@53
  int v51; // [sp+10h] [bp-2Ch]@11
  const char *v52; // [sp+10h] [bp-2Ch]@44
  int v53; // [sp+18h] [bp-24h]@1
  unsigned int v54; // [sp+1Ch] [bp-20h]@1
  int v55; // [sp+20h] [bp-1Ch]@1

  v4 = sub_80491D9(*a1, a2, a3, (int)&v55, (int)&v54, (int)&v53);
  if ( !v4 )
  {
    v5 = *a1;
    if ( src )
    {
      v12 = malloc(strlen(src) + 1 + strlen((const char *)*a1) + 1 - v53 - 1);
      memcpy(v12, (const void *)*a1, v54);
      strcpy((char *)v12 + v54, src);
      strcpy((char *)v12 + v54 + strlen(src), (const char *)(*a1 + v54 + v53));
      free((void *)*a1);
      *a1 = (int)v12;
      return;
    }
    v6 = *a1;
    v7 = -1;
    do
    {
      if ( !v7 )
        break;
      v8 = *(_BYTE *)v6++ == 0;
      --v7;
    }
    while ( !v8 );
    v9 = a3;
    v10 = v7;
    v11 = -1;
    do
    {
      if ( !v11 )
        break;
      v8 = *v9++ == 0;
      --v11;
    }
    while ( !v8 );
    v49 = ~v10 + 1 - v53 - v54 - 1;
    v48 = v5 + v53 + v54;
    v47 = v54 + v11 + 1 + v5;
LABEL_36:
    memmove((void *)v47, (const void *)v48, v49);
    return;
  }
  v51 = v55;
  if ( v55 == -1 )
  {
    if ( src && a3 )
    {
      v33 = *a1;
      v34 = v55;
      do
      {
        if ( !v34 )
          break;
        v8 = *(_BYTE *)v33++ == 0;
        --v34;
      }
      while ( !v8 );
      v35 = a2;
      v50 = v34;
      v36 = v55;
      do
      {
        if ( !v36 )
          break;
        v8 = *v35++ == 0;
        --v36;
      }
      while ( !v8 );
      v37 = a3;
      v38 = v36;
      v39 = v55;
      v40 = ~v38 - v50;
      do
      {
        if ( !v39 )
          break;
        v8 = *v37++ == 0;
        --v39;
      }
      while ( !v8 );
      v41 = src;
      v42 = v39;
      v43 = v55;
      do
      {
        if ( !v43 )
          break;
        v8 = *v41++ == 0;
        --v43;
      }
      while ( !v8 );
      v44 = malloc(~v43 - v42 + v40 + 2);
      v45 = v44;
      strcpy((char *)v44, (const char *)*a1);
      v46 = v51;
      do
      {
        if ( !v46 )
          break;
        v8 = *(_BYTE *)v45 == 0;
        v45 = (char *)v45 + 1;
        --v46;
      }
      while ( !v8 );
      __sprintf_chk((char *)v44 + ~v46 - 1, 1, -1, (const char *)&unk_804E523, a2);
      free((void *)*a1);
      *a1 = (int)v44;
    }
  }
  else
  {
    if ( !a3 )
    {
      v13 = *a1;
      for ( i = v55 + 3; ; i = v17 )
      {
        v15 = v13 + i;
        if ( !*(_BYTE *)(v13 + i) )
          break;
        while ( 1 )
        {
          LOBYTE(v4) = *(_BYTE *)v15;
          if ( *(_BYTE *)v15 != 9 )
          {
            if ( (_BYTE)v4 != 32 && (_BYTE)v4 != 13 && (_BYTE)v4 != 10 )
              break;
          }
          ++i;
          ++v15;
        }
        v16 = v13 + i;
        v17 = i;
        v18 = v4;
        while ( 1 )
        {
          v19 = *(_BYTE *)v16;
          if ( *(_BYTE *)v16 == 10 )
            break;
          if ( v19 == 13 )
            break;
          ++v16;
          if ( !v19 )
            break;
          ++v17;
        }
        v4 = v18;
        if ( (_BYTE)v18 == 91 )
        {
          v20 = i + 1;
          v21 = i;
          v4 = v13 + i;
          while ( v20 < v17 )
          {
            v22 = *(_BYTE *)(v4++ + 1);
            if ( v22 == 93 )
            {
              v23 = v21;
              goto LABEL_33;
            }
            ++v20;
          }
        }
      }
      v23 = -1;
LABEL_33:
      v54 = v23;
      if ( v23 <= v55 )
      {
        *(_BYTE *)(v13 + v55) = 0;
        return;
      }
      v49 = strlen((const char *)v13) + 1 - v23;
      v48 = v13 + v23;
      v47 = v55 + v13;
      goto LABEL_36;
    }
    if ( src )
    {
      v24 = *a1;
      v25 = -1;
      do
      {
        if ( !v25 )
          break;
        v8 = *(_BYTE *)v24++ == 0;
        --v25;
      }
      while ( !v8 );
      v26 = a3;
      v27 = v25;
      v28 = -1;
      do
      {
        if ( !v28 )
          break;
        v8 = *v26++ == 0;
        --v28;
      }
      while ( !v8 );
      v29 = malloc(strlen(src) + 1 + -v27 - v28 - 1);
      v30 = a2;
      v31 = -1;
      v32 = *a1;
      v52 = (const char *)v29;
      do
      {
        if ( !v31 )
          break;
        v8 = *v30++ == 0;
        --v31;
      }
      while ( !v8 );
      v53 = v55 - v31;
      memcpy(v29, (const void *)v32, v55 - v31);
      __sprintf_chk((char *)v29 + v53, 1, -1, "\n%s=%s", a3, src);
      strcpy((char *)&v52[strlen(v52)], (const char *)(v53 + *a1));
      free((void *)*a1);
      *a1 = (int)v52;
    }
  }
}
// 804906C: using guessed type int __sprintf_chk(_DWORD, _DWORD, _DWORD, const char *, ...);

//----- (080495DC) --------------------------------------------------------
int __cdecl sub_80495DC(int *a1, const char *a2, const char *a3, int a4)
{
  int v4; // ecx@1
  int result; // eax@1
  char src; // [sp+23h] [bp-31h]@1
  int v7; // [sp+38h] [bp-1Ch]@1

  v7 = *MK_FP(__GS__, 20);
  __sprintf_chk(&src, 1, 21, "%d", a4);
  sub_80492EF(a1, a2, a3, &src);
  result = *MK_FP(__GS__, 20) ^ v7;
  if ( *MK_FP(__GS__, 20) != v7 )
    __stack_chk_fail(v4);
  return result;
}
// 8048FCC: using guessed type int __fastcall __stack_chk_fail(_DWORD);
// 804906C: using guessed type int __sprintf_chk(_DWORD, _DWORD, _DWORD, const char *, ...);

//----- (0804963C) --------------------------------------------------------
signed int __cdecl sub_804963C(int a1, const char *a2, const char *a3, const char *src, char *dest, size_t n)
{
  signed int result; // eax@3
  size_t v7; // ecx@6
  char *v8; // edi@6
  size_t v9; // [sp+8h] [bp-24h]@1
  int v10; // [sp+Ch] [bp-20h]@1
  char v11; // [sp+10h] [bp-1Ch]@1

  if ( !sub_80491D9(a1, a2, a3, (int)&v11, (int)&v10, (int)&v9) && v9 )
  {
    if ( n - 1 < v9 )
      v9 = n - 1;
    v7 = n;
    v8 = dest;
    while ( v7 )
    {
      *v8++ = 0;
      --v7;
    }
    strncpy(dest, (const char *)(v10 + a1), v9);
    result = 0;
  }
  else
  {
    strncpy(dest, src, n);
    result = -1;
  }
  return result;
}

//----- (080496B3) --------------------------------------------------------
int __cdecl sub_80496B3(int a1, const char *a2, const char *a3, int a4)
{
  signed int v4; // ecx@1
  int v5; // ebx@1
  char *v6; // edi@1
  int v7; // ecx@4
  int result; // eax@6
  char dest; // [sp+Fh] [bp-21h]@1
  int v10; // [sp+24h] [bp-Ch]@1

  v4 = 21;
  v5 = a4;
  v10 = *MK_FP(__GS__, 20);
  v6 = &dest;
  while ( v4 )
  {
    *v6++ = 0;
    --v4;
  }
  sub_804963C(a1, a2, a3, "", &dest, 0x15u);
  if ( dest )
    v5 = atoi(&dest);
  result = v5;
  if ( *MK_FP(__GS__, 20) != v10 )
    __stack_chk_fail(v7);
  return result;
}
// 8048FCC: using guessed type int __fastcall __stack_chk_fail(_DWORD);

//----- (0804971D) --------------------------------------------------------
__int32 __cdecl sub_804971D(void **a1, const char *filename)
{
  __int32 v2; // ebx@1
  FILE *v3; // eax@1
  FILE *v4; // esi@1
  void *v5; // eax@2

  v2 = -1;
  v3 = fopen(filename, "rb");
  v4 = v3;
  if ( v3 )
  {
    fseek(v3, 0, 2);
    v2 = ftell(v4);
    rewind(v4);
    v5 = malloc(v2 + 1);
    *a1 = v5;
    *((_BYTE *)v5 + v2) = 0;
    if ( !fread(v5, v2, 1u, v4) )
    {
      v2 = -1;
      free(*a1);
    }
    fclose(v4);
  }
  return v2;
}

//----- (080497D9) --------------------------------------------------------
int __usercall sub_80497D9<eax>(int a1<eax>, int a2<edx>)
{
  int v2; // ebx@1
  int v3; // esi@1
  int v4; // ecx@1
  int v5; // edx@3
  int v6; // edx@3
  int v7; // eax@3
  int v8; // eax@3
  int v9; // ecx@3
  int v10; // ecx@3
  int v11; // ebx@3
  int v12; // ebx@3
  int v13; // edx@3
  int v14; // edx@3
  int v15; // eax@3
  int v16; // eax@3
  int v17; // esi@3
  int v18; // esi@3
  int v19; // ecx@3
  int v20; // ecx@3
  int v21; // edx@3
  int v22; // edx@3
  int v23; // ebx@3
  int v24; // ebx@3
  int v25; // eax@3
  int v26; // eax@3
  int v27; // ecx@3
  int v28; // ecx@3
  int v29; // esi@3
  int v30; // esi@3
  int v31; // edx@3
  int v32; // edx@3
  int v33; // eax@3
  int v34; // eax@3
  int v35; // ecx@3
  int v36; // ecx@3
  int v37; // ebx@3
  int v38; // ebx@3
  int v39; // esi@3
  int v40; // esi@3
  int v41; // edx@3
  int v42; // edx@3
  int v43; // eax@3
  int v44; // eax@3
  int v45; // ebx@3
  int v46; // ebx@3
  int v47; // ecx@3
  int v48; // ecx@3
  int v49; // edx@3
  int v50; // edx@3
  int v51; // esi@3
  int v52; // esi@3
  int v53; // eax@3
  int v54; // eax@3
  int v55; // ecx@3
  int v56; // ecx@3
  int v57; // ebx@3
  int v58; // ebx@3
  int v59; // edx@3
  int v60; // edx@3
  int v61; // eax@3
  int v62; // eax@3
  int v63; // esi@3
  int v64; // esi@3
  int v65; // ecx@3
  int v66; // ecx@3
  int v67; // edx@3
  int v68; // edx@3
  int v69; // eax@3
  int v70; // eax@3
  int v71; // ebx@3
  int v72; // ebx@3
  int v73; // ecx@3
  int v74; // ecx@3
  int v75; // edx@3
  int v76; // edx@3
  int v77; // eax@3
  int v78; // eax@3
  int v79; // ebx@3
  int v80; // ebx@3
  int v81; // ecx@3
  int v82; // ecx@3
  int v83; // edx@3
  int v84; // edx@3
  int v85; // esi@3
  int v86; // esi@3
  int v87; // ebx@3
  int v88; // ebx@3
  int v89; // eax@3
  int v90; // eax@3
  int v91; // ecx@3
  int v92; // ecx@3
  int v93; // esi@3
  int v94; // esi@3
  int v95; // edx@3
  int v96; // edx@3
  int v97; // ebx@3
  int v98; // ebx@3
  int v99; // ecx@3
  int v100; // ecx@3
  int v101; // eax@3
  int v102; // eax@3
  int v103; // edx@3
  int v104; // edx@3
  int v105; // ebx@3
  int v106; // ebx@3
  int v107; // ecx@3
  int v108; // ecx@3
  int v109; // esi@3
  int v110; // esi@3
  int v111; // edx@3
  int v112; // edx@3
  int v113; // ebx@3
  int v114; // ebx@3
  int v115; // eax@3
  int v116; // eax@3
  int v117; // ecx@3
  int v118; // ecx@3
  int v119; // edx@3
  int v120; // edx@3
  int v121; // ebx@3
  int v122; // ebx@3
  int v123; // eax@3
  int v124; // eax@3
  int v125; // ecx@3
  int v126; // ecx@3
  int v127; // esi@3
  int v128; // esi@3
  int v129; // edx@3
  int v130; // edx@3
  int v131; // eax@3
  int result; // eax@3
  int v133; // [sp+0h] [bp-68h]@1
  int v134; // [sp+4h] [bp-64h]@1
  int v135; // [sp+10h] [bp-58h]@1
  int v136; // [sp+14h] [bp-54h]@1
  int v137; // [sp+18h] [bp-50h]@1
  int v138; // [sp+1Ch] [bp-4Ch]@2
  int v139; // [sp+20h] [bp-48h]@3
  int v140; // [sp+24h] [bp-44h]@3
  int v141; // [sp+28h] [bp-40h]@3
  int v142; // [sp+2Ch] [bp-3Ch]@3
  int v143; // [sp+30h] [bp-38h]@3
  int v144; // [sp+34h] [bp-34h]@3
  int v145; // [sp+38h] [bp-30h]@3
  int v146; // [sp+3Ch] [bp-2Ch]@3
  int v147; // [sp+40h] [bp-28h]@3
  int v148; // [sp+44h] [bp-24h]@3
  int v149; // [sp+48h] [bp-20h]@3
  int v150; // [sp+4Ch] [bp-1Ch]@3
  int v151; // [sp+50h] [bp-18h]@3
  int v152; // [sp+54h] [bp-14h]@3
  int v153; // [sp+58h] [bp-10h]@3

  v137 = a1;
  v135 = *(_DWORD *)a1;
  v2 = *(_DWORD *)(a1 + 4);
  v3 = *(_DWORD *)(a1 + 8);
  v133 = a1 + 8;
  v4 = 0;
  v134 = a1 + 12;
  v136 = *(_DWORD *)(a1 + 12);
  do
  {
    *(int *)((char *)&v138 + v4) = (*(_BYTE *)(a2 + v4 + 3) << 24) | *(_BYTE *)(a2 + v4) | (*(_BYTE *)(a2 + v4 + 2) << 16) | (*(_BYTE *)(a2 + v4 + 1) << 8);
    v4 += 4;
  }
  while ( v4 != 64 );
  v5 = __ROR__((v2 & v3 | v136 & ~v2) + v135 + v138 - 680876936, 25);
  v6 = v2 + v5;
  v7 = __ROR__(v136 + v139 - 389564586 + (v2 & v6 | v3 & ~v6), 20);
  v8 = v6 + v7;
  v9 = __ROR__(v3 + v140 + 606105819 + (v6 & v8 | v2 & ~v8), 15);
  v10 = v8 + v9;
  v11 = __ROR__(v2 + v141 - 1044525330 + (v8 & v10 | v6 & ~v10), 10);
  v12 = v10 + v11;
  v13 = __ROR__(v6 + v142 - 176418897 + (v10 & v12 | v8 & ~v12), 25);
  v14 = v12 + v13;
  v15 = __ROR__(v8 + v143 + 1200080426 + (v12 & v14 | v10 & ~v14), 20);
  v16 = v14 + v15;
  v17 = __ROR__((v14 & v16 | v12 & ~v16) + v10 + v144 - 1473231341, 15);
  v18 = v16 + v17;
  v19 = __ROR__(v12 + v145 - 45705983 + (v16 & v18 | v14 & ~v18), 10);
  v20 = v18 + v19;
  v21 = __ROR__(v14 + v146 + 1770035416 + (v18 & v20 | v16 & ~v20), 25);
  v22 = v20 + v21;
  v23 = __ROR__((v20 & v22 | v18 & ~v22) + v16 + v147 - 1958414417, 20);
  v24 = v22 + v23;
  v25 = __ROR__(v18 + v148 - 42063 + (v22 & v24 | v20 & ~v24), 15);
  v26 = v24 + v25;
  v27 = __ROR__(v20 + v149 - 1990404162 + (v24 & v26 | v22 & ~v26), 10);
  v28 = v26 + v27;
  v29 = __ROR__((v26 & v28 | v24 & ~v28) + v22 + v150 + 1804603682, 25);
  v30 = v28 + v29;
  v31 = __ROR__(v24 + v151 - 40341101 + (v28 & v30 | v26 & ~v30), 20);
  v32 = v30 + v31;
  v33 = __ROR__(v26 + v152 - 1502002290 + (v30 & v32 | v28 & ~v32), 15);
  v34 = v32 + v33;
  v35 = __ROR__(v28 + v153 + 1236535329 + (v32 & v34 | v30 & ~v34), 10);
  v36 = v34 + v35;
  v37 = __ROR__(v30 + v139 - 165796510 + (v34 & ~v32 | v32 & v36), 27);
  v38 = v36 + v37;
  v39 = __ROR__((v36 & ~v34 | v34 & v38) + v32 + v144 - 1069501632, 23);
  v40 = v38 + v39;
  v41 = __ROR__((v38 & ~v36 | v36 & v40) + v34 + v149 + 643717713, 18);
  v42 = v40 + v41;
  v43 = __ROR__(v36 + v138 - 373897302 + (v40 & ~v38 | v38 & v42), 12);
  v44 = v42 + v43;
  v45 = __ROR__((v42 & ~v40 | v40 & v44) + v38 + v143 - 701558691, 27);
  v46 = v44 + v45;
  v47 = __ROR__(v40 + v148 + 38016083 + (v44 & ~v42 | v42 & v46), 23);
  v48 = v46 + v47;
  v49 = __ROR__(v42 + v153 - 660478335 + (v46 & ~v44 | v44 & v48), 18);
  v50 = v48 + v49;
  v51 = __ROR__((v48 & ~v46 | v46 & v50) + v44 + v142 - 405537848, 12);
  v52 = v50 + v51;
  v53 = __ROR__(v46 + v147 + 568446438 + (v50 & ~v48 | v48 & v52), 27);
  v54 = v52 + v53;
  v55 = __ROR__(v48 + v152 - 1019803690 + (v52 & ~v50 | v50 & v54), 23);
  v56 = v54 + v55;
  v57 = __ROR__((v54 & ~v52 | v52 & v56) + v50 + v141 - 187363961, 18);
  v58 = v56 + v57;
  v59 = __ROR__(v52 + v146 + 1163531501 + (v56 & ~v54 | v54 & v58), 12);
  v60 = v58 + v59;
  v61 = __ROR__(v54 + v151 - 1444681467 + (v58 & ~v56 | v56 & v60), 27);
  v62 = v60 + v61;
  v63 = __ROR__((v60 & ~v58 | v58 & v62) + v56 + v140 - 51403784, 23);
  v64 = v62 + v63;
  v65 = __ROR__(v58 + v145 + 1735328473 + (v62 & ~v60 | v60 & v64), 18);
  v66 = v64 + v65;
  v67 = __ROR__(v60 + v150 - 1926607734 + (v64 & ~v62 | v62 & v66), 12);
  v68 = v66 + v67;
  v69 = __ROR__(v62 + v143 - 378558 + (v68 ^ v64 ^ v66), 28);
  v70 = v68 + v69;
  v71 = __ROR__(v64 + v146 - 2022574463 + (v70 ^ v66 ^ v68), 21);
  v72 = v70 + v71;
  v73 = __ROR__(v66 + v149 + 1839030562 + (v72 ^ v68 ^ v70), 16);
  v74 = v72 + v73;
  v75 = __ROR__(v68 + v152 - 35309556 + (v74 ^ v70 ^ v72), 9);
  v76 = v74 + v75;
  v77 = __ROR__(v70 + v139 - 1530992060 + (v76 ^ v72 ^ v74), 28);
  v78 = v76 + v77;
  v79 = __ROR__(v72 + v142 + 1272893353 + (v78 ^ v74 ^ v76), 21);
  v80 = v78 + v79;
  v81 = __ROR__(v74 + v145 - 155497632 + (v80 ^ v76 ^ v78), 16);
  v82 = v80 + v81;
  v83 = __ROR__(v76 + v148 - 1094730640 + (v82 ^ v78 ^ v80), 9);
  v84 = v82 + v83;
  v85 = __ROR__((v84 ^ v80 ^ v82) + v78 + v151 + 681279174, 28);
  v86 = v84 + v85;
  v87 = __ROR__((v86 ^ v82 ^ v84) + v80 + v138 - 358537222, 21);
  v88 = v86 + v87;
  v89 = __ROR__(v82 + v141 - 722521979 + (v88 ^ v84 ^ v86), 16);
  v90 = v88 + v89;
  v91 = __ROR__((v90 ^ v86 ^ v88) + v84 + v144 + 76029189, 9);
  v92 = v90 + v91;
  v93 = __ROR__((v92 ^ v88 ^ v90) + v86 + v147 - 640364487, 28);
  v94 = v92 + v93;
  v95 = __ROR__(v88 + v150 - 421815835 + (v94 ^ v90 ^ v92), 21);
  v96 = v94 + v95;
  v97 = __ROR__((v96 ^ v92 ^ v94) + v90 + v153 + 530742520, 16);
  v98 = v96 + v97;
  v99 = __ROR__((v98 ^ v94 ^ v96) + v92 + v140 - 995338651, 9);
  v100 = v98 + v99;
  v101 = __ROR__(v94 + v138 - 198630844 + (v98 ^ (v100 | ~v96)), 26);
  v102 = v100 + v101;
  v103 = __ROR__(v96 + v145 + 1126891415 + (v100 ^ (v102 | ~v98)), 22);
  v104 = v102 + v103;
  v105 = __ROR__(v98 + v152 - 1416354905 + (v102 ^ (v104 | ~v100)), 17);
  v106 = v104 + v105;
  v107 = __ROR__(v100 + v143 - 57434055 + (v104 ^ (v106 | ~v102)), 11);
  v108 = v106 + v107;
  v109 = __ROR__((v106 ^ (v108 | ~v104)) + v102 + v150 + 1700485571, 26);
  v110 = v108 + v109;
  v111 = __ROR__((v108 ^ (v110 | ~v106)) + v104 + v141 - 1894986606, 22);
  v112 = v110 + v111;
  v113 = __ROR__((v110 ^ (v112 | ~v108)) + v106 + v148 - 1051523, 17);
  v114 = v112 + v113;
  v115 = __ROR__(v108 + v139 - 2054922799 + (v112 ^ (v114 | ~v110)), 11);
  v116 = v114 + v115;
  v117 = __ROR__(v110 + v146 + 1873313359 + (v114 ^ (v116 | ~v112)), 26);
  v118 = v116 + v117;
  v119 = __ROR__(v112 + v153 - 30611744 + (v116 ^ (v118 | ~v114)), 22);
  v120 = v118 + v119;
  v121 = __ROR__(v114 + v144 - 1560198380 + (v118 ^ (v120 | ~v116)), 17);
  v122 = v120 + v121;
  v123 = __ROR__(v116 + v151 + 1309151649 + (v120 ^ (v122 | ~v118)), 11);
  v124 = v122 + v123;
  v125 = __ROR__(v118 + v142 - 145523070 + (v122 ^ (v124 | ~v120)), 26);
  v126 = v124 + v125;
  v127 = __ROR__((v124 ^ (v126 | ~v122)) + v120 + v149 - 1120210379, 22);
  v128 = v126 + v127;
  v129 = __ROR__(v122 + v140 + 718787259 + (v126 ^ (v128 | ~v124)), 17);
  v130 = v128 + v129;
  v131 = __ROR__(v124 + v147 - 343485551 + (v128 ^ (v130 | ~v126)), 11);
  *(_DWORD *)v137 += v126;
  *(_DWORD *)(v137 + 4) += v130 + v131;
  result = v133;
  *(_DWORD *)result += v130;
  *(_DWORD *)v134 += v128;
  return result;
}

//----- (08049F3B) --------------------------------------------------------
unsigned int __cdecl sub_8049F3B(int a1, const void *a2, unsigned int a3)
{
  int v3; // ecx@1
  int v4; // eax@1
  unsigned int v5; // esi@3
  int v6; // edi@4
  unsigned int v8; // [sp+0h] [bp-10h]@3

  v3 = 8 * a3 + *(_DWORD *)(a1 + 16);
  v4 = (*(_DWORD *)(a1 + 16) >> 3) & 0x3F;
  *(_DWORD *)(a1 + 16) = v3;
  if ( v3 < 8 * a3 )
    ++*(_DWORD *)(a1 + 20);
  v5 = 0;
  v8 = 64 - v4;
  *(_DWORD *)(a1 + 20) += a3 >> 29;
  if ( a3 >= 64 - v4 )
  {
    memcpy((void *)(a1 + 24 + v4), a2, v8);
    sub_80497D9(a1, a1 + 24);
    v6 = (int)((char *)a2 + v8);
    v5 = v8;
    while ( v5 + 63 < a3 )
    {
      sub_80497D9(a1, v6);
      v5 += 64;
      v6 += 64;
    }
    v4 = 0;
  }
  memcpy((void *)(a1 + v4 + 24), (char *)a2 + v5, a3 - v5);
  return v8;
}

//----- (08049FCF) --------------------------------------------------------
int __cdecl sub_8049FCF(int a1, int a2)
{
  unsigned int v2; // edx@1
  unsigned int v3; // eax@1
  int v4; // edx@1
  unsigned int v5; // ecx@1
  signed int v6; // eax@1
  int v7; // ecx@3
  int v8; // eax@3
  int result; // eax@5
  char v10; // [sp+4h] [bp-14h]@1
  char v11; // [sp+5h] [bp-13h]@1
  char v12; // [sp+6h] [bp-12h]@1
  char v13; // [sp+7h] [bp-11h]@1
  char v14; // [sp+8h] [bp-10h]@1
  char v15; // [sp+9h] [bp-Fh]@1
  char v16; // [sp+Ah] [bp-Eh]@1
  char v17; // [sp+Bh] [bp-Dh]@1
  int v18; // [sp+Ch] [bp-Ch]@1

  v18 = *MK_FP(__GS__, 20);
  v2 = *(_DWORD *)(a2 + 16);
  v11 = *(_WORD *)(a2 + 16) >> 8;
  v12 = v2 >> 16;
  v10 = v2;
  v13 = BYTE3(v2);
  v3 = *(_DWORD *)(a2 + 20);
  v4 = (v2 >> 3) & 0x3F;
  v15 = *(_WORD *)(a2 + 20) >> 8;
  v5 = v3 >> 16;
  v14 = v3;
  v17 = BYTE3(v3);
  v6 = 56;
  v16 = v5;
  if ( (unsigned int)v4 > 0x37 )
    v6 = 120;
  sub_8049F3B(a2, &unk_80510F4, v6 - v4);
  sub_8049F3B(a2, &v10, 8u);
  v8 = 0;
  do
  {
    *(_BYTE *)(a1 + v8) = *(_DWORD *)(a2 + v8);
    *(_BYTE *)(a1 + v8 + 1) = *(_WORD *)(a2 + v8) >> 8;
    *(_BYTE *)(a1 + v8 + 2) = *(_DWORD *)(a2 + v8) >> 16;
    *(_BYTE *)(a1 + v8 + 3) = *(_DWORD *)(a2 + v8) >> 24;
    v8 += 4;
  }
  while ( v8 != 16 );
  LOBYTE(v8) = 0;
  memset32((void *)a2, v8, 0x16u);
  result = *MK_FP(__GS__, 20) ^ v18;
  if ( *MK_FP(__GS__, 20) != v18 )
    __stack_chk_fail(v7);
  return result;
}
// 8048FCC: using guessed type int __fastcall __stack_chk_fail(_DWORD);

//----- (0804A0A5) --------------------------------------------------------
_UNKNOWN *__cdecl sub_804A0A5(const void *a1, unsigned int a2)
{
  int v2; // ecx@1
  _UNKNOWN *result; // eax@1
  int v4; // [sp+4h] [bp-64h]@1
  int v5; // [sp+8h] [bp-60h]@1
  int v6; // [sp+Ch] [bp-5Ch]@1
  int v7; // [sp+10h] [bp-58h]@1
  int v8; // [sp+14h] [bp-54h]@1
  int v9; // [sp+18h] [bp-50h]@1
  int v10; // [sp+5Ch] [bp-Ch]@1

  v10 = *MK_FP(__GS__, 20);
  v9 = 0;
  v8 = 0;
  v4 = 1732584193;
  v5 = -271733879;
  v6 = -1732584194;
  v7 = 271733878;
  sub_8049F3B((int)&v4, a1, a2);
  sub_8049FCF((int)&unk_805142C, (int)&v4);
  result = &unk_805142C;
  if ( *MK_FP(__GS__, 20) != v10 )
    __stack_chk_fail(v2);
  return result;
}
// 8048FCC: using guessed type int __fastcall __stack_chk_fail(_DWORD);

//----- (0804A166) --------------------------------------------------------
void __cdecl sub_804A166()
{
  if ( ptr )
  {
    free(ptr);
    ptr = 0;
  }
}

//----- (0804A18D) --------------------------------------------------------
signed int __cdecl sub_804A18D(const char *filename)
{
  FILE *v1; // esi@1
  void *v2; // edi@2
  void *v3; // ebx@2
  int v4; // ecx@3
  int v5; // edx@3
  int v6; // ST34_4@4
  int v7; // eax@4
  int v8; // ebx@5
  size_t v9; // ST3C_4@5
  void *v10; // edi@5
  signed int i; // eax@6
  signed int v12; // ebx@9
  int v13; // eax@13
  void *v14; // ST10_4@15
  int v16; // [sp+18h] [bp-28h]@4
  int v17; // [sp+20h] [bp-20h]@3
  int v18; // [sp+20h] [bp-20h]@5
  int size; // [sp+24h] [bp-1Ch]@4

  v1 = fopen(filename, "rb");
  if ( !v1 )
    goto LABEL_23;
  v2 = malloc(0x1000u);
  v3 = v2;
  if ( fread(v2, 0x1000u, 1u, v1) )
  {
    v4 = 0;
    v5 = (int)((char *)v2 + *((_DWORD *)v2 + 15));
    v17 = *(_WORD *)(v5 + 6) - 1;
    do
    {
      v13 = v17 - v4;
      if ( v17 - v4 == -1 )
      {
        v3 = v2;
        goto LABEL_19;
      }
      size = 40 * v13;
      v16 = v5;
      v6 = v4;
      v7 = strcmp((const char *)(v5 + 40 * v13 + 248), ".rsrc");
      v5 = v16;
      v4 = v6 + 1;
    }
    while ( v7 );
    v8 = v16 + size;
    fseek(v1, *(_DWORD *)(v16 + size + 268), 0);
    v9 = *(_DWORD *)(v16 + size + 264);
    v18 = *(_DWORD *)(v8 + 260);
    free(v2);
    v3 = malloc(v9);
    v10 = v3;
    if ( fread(v3, v9, 1u, v1) )
    {
      for ( i = 0; i < *((_WORD *)v3 + 7); ++i )
      {
        if ( *((_WORD *)v3 + 4 * i + 8) == 16 && *((_BYTE *)v3 + 8 * (i + 2) + 3) >= 0 )
        {
          v12 = *(_DWORD *)((char *)v3
                          + *(_DWORD *)((char *)v3
                                      + *(_DWORD *)((char *)v3
                                                  + (*(_DWORD *)((char *)v3
                                                               + (*((_DWORD *)v3 + 2 * (i + 2) + 1) & 0x7FFFFFFF)
                                                               + 20) & 0x7FFFFFFF)
                                                  + 20))
                          - v18
                          + 48);
          fclose(v1);
          free(v10);
          return v12;
        }
      }
    }
  }
LABEL_19:
  fclose(v1);
  if ( v3 )
  {
    v14 = v3;
    v12 = -1;
    free(v14);
  }
  else
  {
LABEL_23:
    v12 = -1;
  }
  return v12;
}

//----- (0804A30D) --------------------------------------------------------
int __cdecl sub_804A30D(const void *a1, int a2)
{
  const void *v2; // ebx@1
  void *v3; // eax@1
  int v4; // edx@1
  int v5; // ST24_4@2
  const void *v6; // eax@2
  _UNKNOWN *v7; // eax@3
  int v8; // edx@3
  int v9; // ecx@4
  int result; // eax@5
  unsigned int v11; // [sp+2Ch] [bp-C8h]@1
  int v12; // [sp+30h] [bp-C4h]@1
  void *ptr; // [sp+34h] [bp-C0h]@1
  unsigned int v14; // [sp+38h] [bp-BCh]@1
  char v15; // [sp+48h] [bp-ACh]@3
  char v16; // [sp+49h] [bp-ABh]@1
  int v17; // [sp+D8h] [bp-1Ch]@1

  v2 = a1;
  v17 = *MK_FP(__GS__, 20);
  v14 = size >> 3;
  v11 = (size >> 3) + 16;
  v3 = malloc((size >> 3) + 16);
  v4 = (int)&v16;
  ptr = v3;
  memcpy(v3, a1, 0x10u);
  v12 = 0;
  do
  {
    memcpy((char *)ptr + 16, (char *)::ptr + v12, v14);
    v5 = v4;
    v6 = sub_804A0A5(ptr, v11);
    *(_BYTE *)(v5 - 1) = *(_BYTE *)v2;
    memcpy((void *)v5, v6, 0x10u);
    LOBYTE(v6) = *((_BYTE *)v2 + 1);
    v2 = (char *)v2 + 2;
    *(_BYTE *)(v5 + 16) = (_BYTE)v6;
    v4 = v5 + 18;
    v12 += v14;
  }
  while ( (int *)(v5 + 18) != (int *)((char *)&v17 + 1) );
  free(ptr);
  v7 = sub_804A0A5(&v15, 0x90u);
  v8 = 0;
  do
  {
    *(_BYTE *)(a2 + 2 * v8) = byte_804E555[(unsigned __int8)(*((_BYTE *)v7 + v8) >> 4)];
    v9 = *((_BYTE *)v7 + v8) & 0xF;
    LOBYTE(v9) = byte_804E555[v9];
    *(_BYTE *)(a2 + 2 * v8++ + 1) = v9;
  }
  while ( v8 != 16 );
  *(_BYTE *)(a2 + 32) = 0;
  result = *MK_FP(__GS__, 20) ^ v17;
  if ( *MK_FP(__GS__, 20) != v17 )
    __stack_chk_fail(v9);
  return result;
}
// 8048FCC: using guessed type int __fastcall __stack_chk_fail(_DWORD);

//----- (0804A46D) --------------------------------------------------------
int __usercall sub_804A46D<eax>(unsigned __int8 *a1<eax>, unsigned int a2<edx>, unsigned int a3<ecx>, int a4)
{
  unsigned int v4; // esi@1
  unsigned __int8 *v5; // ebx@1
  unsigned int i; // eax@1
  __int64 v7; // qax@4
  int v8; // ebx@4
  int v10; // [sp+Ch] [bp-804Ch]@5
  unsigned int v11; // [sp+20h] [bp-8038h]@1
  unsigned __int8 *v12; // [sp+24h] [bp-8034h]@1
  unsigned __int8 v13; // [sp+2Bh] [bp-802Dh]@4
  int v14; // [sp+2Ch] [bp-802Ch]@5
  char v15[32768]; // [sp+3Ch] [bp-801Ch]@1
  int v16; // [sp+803Ch] [bp-1Ch]@1

  v4 = a2;
  v5 = a1;
  v16 = *MK_FP(__GS__, 20);
  v12 = &a1[a3 + 1];
  v11 = a2 + a4;
  memset(v15, 538976288, sizeof(v15));
  for ( i = 0; i < a3; ++i )
    v5[i] = ~v5[i];
  LOBYTE(a3) = *v5;
  v7 = 0LL;
  v8 = (int)(v5 + 1);
  v13 = a3;
LABEL_14:
  if ( v8 < (unsigned int)v12 )
  {
    a3 = 0;
    v14 = v7;
    v10 = 0;
    while ( 1 )
    {
      if ( (unsigned __int8)(1 << v10) & v13 )
      {
        LOBYTE(a3) = v15[(unsigned int)v7 ^ (HIDWORD(v7) << 7)];
      }
      else
      {
        LOBYTE(a3) = *(_BYTE *)v8++;
        if ( v8 >= (unsigned int)v12 )
          break;
        v15[(unsigned int)v7 ^ (HIDWORD(v7) << 7)] = a3;
      }
      *(_BYTE *)v4++ = a3;
      if ( v4 >= v11 )
        break;
      ++v10;
      LODWORD(v7) = (unsigned __int8)a3;
      HIDWORD(v7) = v14;
      if ( v10 == 8 )
      {
        LOBYTE(a3) = *(_BYTE *)v8++;
        v13 = a3;
        goto LABEL_14;
      }
      v14 = (unsigned __int8)a3;
    }
  }
  if ( *MK_FP(__GS__, 20) != v16 )
    __stack_chk_fail(a3);
  return v7;
}
// 8048FCC: using guessed type int __fastcall __stack_chk_fail(_DWORD);
// 804A46D: using guessed type char var_801C[32768];

//----- (0804A58B) --------------------------------------------------------
signed int __cdecl sub_804A58B(const char *filename, unsigned int a2, int a3)
{
  __int32 v3; // ecx@1
  signed int result; // eax@1
  void *ptr; // [sp+14h] [bp-Ch]@1

  v3 = sub_804971D(&ptr, filename);
  result = -1;
  if ( v3 >= 0 )
  {
    sub_804A46D((unsigned __int8 *)ptr, a2, v3, a3);
    free(ptr);
    result = 0;
  }
  return result;
}

//----- (0804A5CA) --------------------------------------------------------
signed int __cdecl sub_804A5CA(const char *a1)
{
  char *v1; // eax@1
  void *v2; // ebx@3
  int v3; // ecx@3
  FILE *v4; // esi@3
  void *v5; // edi@4
  int v6; // edx@5
  signed int i; // eax@5
  int v8; // ecx@6
  int v9; // ebx@7
  void *v10; // ST10_4@24
  FILE *v11; // eax@13
  FILE *v12; // esi@13
  signed int result; // eax@19
  char filename; // [sp+1Ch] [bp-12Ch]@1
  int ptr; // [sp+11Ch] [bp-2Ch]@14
  int v16; // [sp+120h] [bp-28h]@15
  int v17; // [sp+12Ch] [bp-1Ch]@1

  v17 = *MK_FP(__GS__, 20);
  sub_804A166();
  __strcpy_chk(&filename, a1, 256);
  v1 = strrchr(&filename, 47) + 1;
  if ( v1 == (char *)1 )
    v1 = &filename;
  strcpy(v1, "8021x.exe");
  v2 = 0;
  v4 = fopen(&filename, "rb");
  if ( v4 )
  {
    v5 = malloc(0x1000u);
    v2 = v5;
    if ( fread(v5, 0x1000u, 1u, v4) )
    {
      v6 = (int)((char *)v5 + *((_DWORD *)v5 + 15));
      for ( i = 0; i < *(_WORD *)((char *)v5 + *((_DWORD *)v5 + 15) + 6); ++i )
      {
        v8 = *(_DWORD *)(v6 + 284);
        v6 += 40;
        if ( v8 & 0x20000020 )
        {
          v9 = (int)((char *)v5 + 40 * i + *((_DWORD *)v5 + 15));
          fseek(v4, *(_DWORD *)(v9 + 268), 0);
          size = *(_DWORD *)(v9 + 264);
          free(v5);
          v2 = malloc(size);
          if ( !fread(v2, size, 1u, v4) )
            break;
          fclose(v4);
          goto LABEL_12;
        }
      }
    }
    fclose(v4);
    if ( v2 )
    {
      v10 = v2;
      v2 = 0;
      free(v10);
    }
  }
LABEL_12:
  ::ptr = v2;
  if ( !v2 )
  {
    v11 = fopen(a1, "rb");
    v12 = v11;
    if ( !v11 )
      goto LABEL_19;
    if ( fread(&ptr, 0x10u, 1u, v11) )
    {
      size = ptr ^ v16;
      if ( !((ptr ^ v16) < 0 | ptr == v16) )
      {
        v2 = malloc((ptr ^ v16) + 256);
        if ( fread(v2, size, 1u, v12) )
        {
          fclose(v12);
          goto LABEL_19;
        }
        free(v2);
      }
    }
    v2 = 0;
    fclose(v12);
LABEL_19:
    result = -1;
    ::ptr = v2;
    if ( !v2 )
      goto LABEL_21;
  }
  result = 0;
LABEL_21:
  if ( *MK_FP(__GS__, 20) != v17 )
    __stack_chk_fail(v3);
  return result;
}
// 8048F7C: using guessed type int __cdecl __strcpy_chk(_DWORD, _DWORD, _DWORD);
// 8048FCC: using guessed type int __fastcall __stack_chk_fail(_DWORD);

//----- (0804A800) --------------------------------------------------------
char *__cdecl sub_804A800()
{
  void *v0; // ebx@2
  char *result; // eax@5

  if ( dword_8051444 )
  {
    v0 = dlsym(handle, "notify_uninit");
    if ( !dlerror() )
      ((void (*)(void))v0)();
    dword_8051444 = 0;
  }
  result = (char *)handle;
  if ( handle )
  {
    dlclose(handle);
    result = dlerror();
    handle = 0;
  }
  return result;
}
// 8051444: using guessed type int dword_8051444;

//----- (0804A865) --------------------------------------------------------
signed int __cdecl sub_804A865(int a1, int a2, int a3)
{
  __uid_t v3; // eax@1
  int v4; // edx@1
  char *v5; // eax@6
  void *v6; // edi@7
  char *v7; // ebx@7
  void *v8; // esi@8
  char *v9; // eax@12
  int v11; // ST18_4@18
  int v12; // ST1C_4@18
  char *v13; // [sp-8h] [bp-30h]@12
  void *v14; // [sp-4h] [bp-2Ch]@12

  v3 = getuid();
  seteuid(v3);
  if ( !dword_8051444 )
  {
    if ( !handle )
    {
      handle = dlopen("libnotify.so", 1);
      dlerror();
      if ( !handle )
      {
        handle = dlopen("libnotify.so.1", 1);
        dlerror();
      }
    }
    if ( !handle )
    {
      v5 = dcgettext(0, "!! libnotify\n", 5);
      __printf_chk(1, v5);
LABEL_17:
      seteuid(0);
      return -1;
    }
    v6 = dlsym(handle, "notify_init");
    v7 = dlerror();
    if ( v7
      || (v8 = dlsym(handle, "notify_notification_new"), (v7 = dlerror()) != 0)
      || (dword_8051458 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))dlsym(handle, "notify_notification_show"),
          (v7 = dlerror()) != 0)
      || (dword_8051450 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))dlsym(handle, "notify_notification_update"),
          (v7 = dlerror()) != 0)
      || (dword_8051454 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))dlsym(
                                                                             handle,
                                                                             "notify_notification_set_timeout"),
          (v7 = dlerror()) != 0) )
    {
      v14 = v6;
      v9 = dcgettext(0, "!! libnotify: %s\n", 5);
      v13 = v7;
LABEL_16:
      __printf_chk(1, v9, v13, v14);
      sub_804A800();
      goto LABEL_17;
    }
    if ( !((int (__cdecl *)(_DWORD))v6)("mentohust")
      || (dword_8051444 = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))v8)("MentoHUST", 0, 0, 0)) == 0 )
    {
      v14 = v8;
      v9 = dcgettext(0, "!! libnotify\n", 5);
      goto LABEL_16;
    }
  }
  dword_8051454(dword_8051444, a3, v4, v4);
  dword_8051450(dword_8051444, a1, a2, 0);
  dword_8051458(dword_8051444, 0, v11, v12);
  seteuid(0);
  return 0;
}
// 8048DBC: using guessed type int __printf_chk(_DWORD, const char *, ...);
// 8051450: using guessed type int (__cdecl *dword_8051450)(_DWORD, _DWORD, _DWORD, _DWORD);
// 8051454: using guessed type int (__cdecl *dword_8051454)(_DWORD, _DWORD, _DWORD, _DWORD);
// 8051458: using guessed type int (__stdcall *dword_8051458)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804AA78) --------------------------------------------------------
char *__cdecl sub_804AA78()
{
  char *result; // eax@1

  result = (char *)dword_805144C;
  if ( dword_805144C )
  {
    dlclose(dword_805144C);
    result = dlerror();
    dword_805144C = 0;
  }
  return result;
}

//----- (0804AAA4) --------------------------------------------------------
signed int __cdecl sub_804AAA4()
{
  int v0; // esi@1
  const char *v1; // ST00_4@2
  char *v2; // eax@5
  char *v3; // esi@6
  signed int result; // eax@16
  char *v5; // eax@17
  char v6[28]; // [sp+Ch] [bp-1Ch]@1

  memcpy(v6, off_804E7F0, 0x14u);
  v0 = 0;
  do
  {
    if ( dword_805144C )
      break;
    v1 = *(const char **)&v6[4 * v0++];
    dword_805144C = dlopen(v1, 1);
    dlerror();
  }
  while ( v0 != 5 );
  if ( !dword_805144C )
  {
    v2 = dcgettext(0, "!! libpcap\n", 5);
    __printf_chk(1, v2);
    return -1;
  }
  dword_8051A24 = (int (__cdecl *)(_DWORD, _DWORD))dlsym(dword_805144C, "pcap_findalldevs");
  v3 = dlerror();
  if ( v3
    || (dword_8051A3C = (int (__cdecl *)(_DWORD))dlsym(dword_805144C, "pcap_freealldevs"), (v3 = dlerror()) != 0)
    || (dword_8051A30 = (int)dlsym(dword_805144C, "pcap_open_live"), (v3 = dlerror()) != 0)
    || (dword_8051A38 = (int)dlsym(dword_805144C, "pcap_compile"), (v3 = dlerror()) != 0)
    || (dword_8051A44 = (int)dlsym(dword_805144C, "pcap_setfilter"), (v3 = dlerror()) != 0)
    || (dword_8051A34 = (int)dlsym(dword_805144C, "pcap_geterr"), (v3 = dlerror()) != 0)
    || (dword_8051A48 = (int)dlsym(dword_805144C, "pcap_freecode"), (v3 = dlerror()) != 0)
    || (dword_8051A4C = (int)dlsym(dword_805144C, "pcap_loop"), (v3 = dlerror()) != 0)
    || (dword_8051A2C = (int (__cdecl *)(_DWORD))dlsym(dword_805144C, "pcap_close"), (v3 = dlerror()) != 0)
    || (dword_8051A40 = (int (__cdecl *)(_DWORD))dlsym(dword_805144C, "pcap_breakloop"), (v3 = dlerror()) != 0)
    || (dword_8051A28 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))dlsym(dword_805144C, "pcap_sendpacket"),
        v3 = dlerror(),
        result = 0,
        v3) )
  {
    v5 = dcgettext(0, "!! libpcap: %s\n", 5);
    __printf_chk(1, v5, v3, v6);
    sub_804AA78();
    return -1;
  }
  return result;
}
// 8048DBC: using guessed type int __printf_chk(_DWORD, const char *, ...);
// 804E7F0: using guessed type char *off_804E7F0[5];
// 8051A24: using guessed type int (__cdecl *dword_8051A24)(_DWORD, _DWORD);
// 8051A28: using guessed type int (__cdecl *dword_8051A28)(_DWORD, _DWORD, _DWORD, _DWORD);
// 8051A2C: using guessed type int (__cdecl *dword_8051A2C)(_DWORD);
// 8051A30: using guessed type int dword_8051A30;
// 8051A34: using guessed type int dword_8051A34;
// 8051A38: using guessed type int dword_8051A38;
// 8051A3C: using guessed type int (__cdecl *dword_8051A3C)(_DWORD);
// 8051A40: using guessed type int (__cdecl *dword_8051A40)(_DWORD);
// 8051A44: using guessed type int dword_8051A44;
// 8051A48: using guessed type int dword_8051A48;
// 8051A4C: using guessed type int dword_8051A4C;
// 804AAA4: using guessed type char var_1C[28];

//----- (0804ACF0) --------------------------------------------------------
int __usercall sub_804ACF0<eax>(int a1<eax>)
{
  int v1; // edx@1
  int v2; // ebx@1
  int v3; // esi@1
  unsigned __int8 v4; // cl@2
  unsigned __int8 v5; // bl@4
  int v6; // esi@4
  int v7; // ecx@4
  signed int v8; // ecx@6
  int result; // eax@7
  char v10; // [sp+Ch] [bp-21Ch]@1
  char v11[511]; // [sp+Dh] [bp-21Bh]@2
  int v12; // [sp+20Ch] [bp-1Ch]@1

  v12 = *MK_FP(__GS__, 20);
  v1 = 0;
  v2 = a1 + 22;
  memcpy(&v10, &unk_804EC74, 0x200u);
  v3 = a1 + 21;
  do
  {
    v4 = *(_BYTE *)(a1 + v1++) ^ *(_BYTE *)v3;
    *(_BYTE *)v3 = *(_BYTE *)v2 ^ v11[2 * v4];
    *(_BYTE *)v2 = *(&v10 + 2 * v4);
  }
  while ( v1 != 21 );
  LOBYTE(v1) = 0;
  do
  {
    v5 = *(_BYTE *)(a1 + v1);
    v6 = 0;
    v7 = 0;
    do
    {
      ++v6;
      v7 = v5 & 1 | 2 * v7;
      v5 >>= 1;
    }
    while ( v6 != 8 );
    v8 = ~v7;
    *(_BYTE *)(a1 + v1++) = v8;
  }
  while ( v1 != 23 );
  result = *MK_FP(__GS__, 20) ^ v12;
  if ( *MK_FP(__GS__, 20) != v12 )
    __stack_chk_fail(v8);
  return result;
}
// 8048FCC: using guessed type int __fastcall __stack_chk_fail(_DWORD);
// 804ACF0: using guessed type char var_21B[511];

//----- (0804AD88) --------------------------------------------------------
int __cdecl sub_804AD88(int a1)
{
  int v1; // ecx@1
  int v2; // edx@1
  int v3; // edi@2
  int v4; // eax@2
  char v5; // bl@3
  int v7; // [sp+0h] [bp-10h]@0

  v1 = a1 + *(_BYTE *)(a1 + 27) + 157;
  v2 = 0;
  do
  {
    v3 = 0;
    BYTE3(v7) = *(_BYTE *)v1;
    v4 = 0;
    do
    {
      v5 = BYTE3(v7);
      ++v3;
      BYTE3(v7) >>= 1;
      v4 = v5 & 1 | 2 * v4;
    }
    while ( v3 != 8 );
    ++v1;
    *((_BYTE *)&dword_805146C + v2++) = ~(_BYTE)v4;
  }
  while ( v2 != 4 );
  dword_805146C = _byteswap_ulong(dword_805146C);
  return v7;
}
// 805146C: using guessed type int dword_805146C;

//----- (0804ADE0) --------------------------------------------------------
int __cdecl sub_804ADE0(int a1)
{
  unsigned __int32 v1; // ecx@1
  unsigned __int32 v2; // edx@1
  int result; // eax@1
  unsigned __int8 v4; // cl@2
  int v5; // edx@2
  int v6; // edx@4
  unsigned __int8 v7; // cl@4
  int v8; // [sp+0h] [bp-28h]@2
  int v9; // [sp+8h] [bp-20h]@2
  int v10; // [sp+8h] [bp-20h]@4
  unsigned __int32 v11; // [sp+14h] [bp-14h]@1
  unsigned __int32 v12; // [sp+18h] [bp-10h]@1

  v1 = _byteswap_ulong(dword_8051470 + dword_805146C);
  v2 = _byteswap_ulong(dword_8051470++);
  result = 0;
  v12 = v1;
  v11 = v2;
  do
  {
    v4 = *((_BYTE *)&v12 + result);
    v5 = 0;
    v9 = 0;
    v8 = result;
    do
    {
      ++v9;
      v5 = v4 & 1 | 2 * v5;
      v4 >>= 1;
    }
    while ( v9 != 8 );
    *(_BYTE *)(a1 + result + 24) = ~(_BYTE)v5;
    v6 = 0;
    v7 = *((_BYTE *)&v11 + result);
    v10 = 0;
    do
    {
      ++v10;
      v6 = v7 & 1 | 2 * v6;
      v7 >>= 1;
    }
    while ( v10 != 8 );
    *(_BYTE *)(a1 + result++ + 34) = ~(_BYTE)v6;
  }
  while ( v8 != 3 );
  return result;
}
// 805146C: using guessed type int dword_805146C;
// 8051470: using guessed type int dword_8051470;

//----- (0804AE79) --------------------------------------------------------
int __cdecl sub_804AE79(int a1)
{
  int result; // eax@1
  int v2; // edx@1

  result = a1;
  *(_DWORD *)(a1 + 24) = dword_8051A00;
  *(_DWORD *)(a1 + 28) = dword_8051A04;
  v2 = dword_8051A08;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 32) = v2;
  return result;
}
// 8051A00: using guessed type int dword_8051A00;
// 8051A04: using guessed type int dword_8051A04;
// 8051A08: using guessed type int dword_8051A08;

//----- (0804AEA3) --------------------------------------------------------
signed int __usercall sub_804AEA3<eax>(char a1<al>, const void *a2<edx>, unsigned int a3<ecx>)
{
  const void *v3; // esi@1
  size_t i; // edx@1
  signed int result; // eax@5

  v3 = a2;
  for ( i = dword_805145C + 70; i < dword_805145C - a3 + dword_8051460 - 8; i += *(_BYTE *)(i + 5) + 4 )
  {
    if ( *(_BYTE *)i == 26 )
      i += 2;
    if ( *(_BYTE *)(i + 4) == a1 )
    {
      result = 0;
      memcpy((void *)(i + *(_BYTE *)(i + 5) + 4 - a3), v3, a3);
      return result;
    }
  }
  return -1;
}

//----- (0804AEFB) --------------------------------------------------------
_UNKNOWN *__cdecl sub_804AEFB(char a1, const void *a2, unsigned int a3)
{
  signed int v3; // ecx@1
  FILE *v4; // edi@1
  char v5; // zf@3
  int v6; // ebx@4
  unsigned int v7; // ecx@4
  _UNKNOWN *result; // eax@6
  int v9; // ecx@6
  int v10; // [sp+8h] [bp-80h]@4
  char v11; // [sp+1Ch] [bp-6Ch]@4
  char v12; // [sp+1Dh] [bp-6Bh]@4
  int v13; // [sp+6Ch] [bp-1Ch]@1

  v3 = -1;
  v4 = &stream;
  v13 = *MK_FP(__GS__, 20);
  do
  {
    if ( !v3 )
      break;
    v5 = LOBYTE(v4->_flags) == 0;
    v4 = (FILE *)((char *)v4 + 1);
    --v3;
  }
  while ( !v5 );
  v11 = a1;
  v10 = ~v3;
  __memcpy_chk(&v12, &stream, ~v3 - 1, 79);
  v6 = v10;
  v7 = 3;
  if ( dword_8051A14 % 3u == 2 )
  {
    LOBYTE(v7) = 10;
    memcpy(&v11 + v10, "xxghlmxhzb", v7);
    v6 = v10 + 10;
  }
  memcpy(&v11 + v6, a2, a3);
  result = sub_804A0A5(&v11, a3 + v6);
  if ( *MK_FP(__GS__, 20) != v13 )
    __stack_chk_fail(v9);
  return result;
}
// 8048E3C: using guessed type int __cdecl __memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD);
// 8048FCC: using guessed type int __fastcall __stack_chk_fail(_DWORD);
// 8051A14: using guessed type int dword_8051A14;

//----- (0804AFA5) --------------------------------------------------------
signed int __usercall sub_804AFA5<eax>(signed int a1<eax>)
{
  signed int v1; // esi@1
  FILE *v2; // eax@1
  FILE *v3; // ebx@1
  signed int result; // eax@6
  char *v5; // eax@8
  char v6; // [sp+17h] [bp-9h]@1

  v1 = a1;
  v6 = 0;
  v2 = fopen((const char *)&stream.__pad1, "rb");
  v3 = v2;
  if ( !v2 )
  {
LABEL_8:
    v5 = dcgettext(0, "!! %s\n", 5);
    __printf_chk(1, v5, &stream.__pad1, v3);
    dword_8051464 -= 2;
    if ( dword_8051464 != 1 || (signed int)dword_8051460 > 470 )
    {
      result = -1;
    }
    else
    {
      free((void *)dword_805145C);
      dword_8051460 = 471;
      dword_805145C = (size_t)malloc(0x1D7u);
      result = -1;
    }
    return result;
  }
  fseek(v2, dword_8051608 + (dword_8051460 - 23) * v1 % 2, 0);
  if ( !fread((void *)(dword_805145C + 23), dword_8051460 - 23, 1u, v3) )
  {
    fclose(v3);
    goto LABEL_8;
  }
  fclose(v3);
  if ( dword_8051A18 == 1 )
    v6 = 1;
  sub_804AEA3(24, &v6, 1u);
  sub_804AEA3(45, &dword_8051A64, 6u);
  result = 0;
  if ( dword_8051464 == 3 )
  {
    *(_WORD *)(dword_805145C + 59) = word_8051A50;
    result = 0;
  }
  return result;
}
// 8048DBC: using guessed type int __printf_chk(_DWORD, const char *, ...);
// 8051464: using guessed type int dword_8051464;
// 8051608: using guessed type int dword_8051608;
// 8051A18: using guessed type int dword_8051A18;
// 8051A50: using guessed type __int16 word_8051A50;
// 8051A64: using guessed type int dword_8051A64;

//----- (0804B0FE) --------------------------------------------------------
int __cdecl sub_804B0FE()
{
  int v0; // ecx@7
  int result; // eax@10
  char v2; // [sp+Bh] [bp-22Dh]@2
  char v3; // [sp+Ch] [bp-22Ch]@2
  char v4; // [sp+1CCh] [bp-6Ch]@2
  int v5; // [sp+22Ch] [bp-Ch]@1

  v5 = *MK_FP(__GS__, 20);
  if ( dword_8051464 > 1 )
  {
    if ( sub_804AFA5(0) == -1 )
      sub_804B0FE();
  }
  else
  {
    memcpy(&v4, &unk_804EC14, 0x60u);
    v2 = 0;
    memcpy(&v3, &unk_804EA54, 0x1C0u);
    if ( dword_8051A18 == 1 )
      v2 = 1;
    if ( dword_8051464 == 1 )
    {
      memcpy((void *)(dword_805145C + 23), &v3, 0x1C0u);
      *(_WORD *)(dword_805145C + 59) = word_8051A50;
    }
    else
    {
      memcpy((void *)(dword_805145C + 23), &v4, 0x60u);
    }
    sub_804AEA3(24, &v2, 1u);
    sub_804AEA3(45, &dword_8051A64, 6u);
  }
  result = *MK_FP(__GS__, 20) ^ v5;
  if ( *MK_FP(__GS__, 20) != v5 )
    __stack_chk_fail(v0);
  return result;
}
// 8048FCC: using guessed type int __fastcall __stack_chk_fail(_DWORD);
// 8051464: using guessed type int dword_8051464;
// 8051A18: using guessed type int dword_8051A18;
// 8051A50: using guessed type __int16 word_8051A50;
// 8051A64: using guessed type int dword_8051A64;

//----- (0804B1E7) --------------------------------------------------------
#error "804B28C: positive sp value has been found (funcsize=48)"

//----- (0804B28D) --------------------------------------------------------
int __cdecl sub_804B28D()
{
  FILE *v0; // eax@3
  int v1; // edx@3
  FILE *v2; // edi@3
  int v3; // eax@8
  int v4; // ST0C_4@10
  char *v5; // eax@10
  int v6; // ecx@12
  int result; // eax@12
  char ptr; // [sp+Ch] [bp-1Ch]@4
  int v9; // [sp+14h] [bp-14h]@7
  int v10; // [sp+1Ch] [bp-Ch]@1

  v10 = *MK_FP(__GS__, 20);
  if ( !LOBYTE(stream.__pad1) )
    strcpy((char *)&stream.__pad1, off_804EE74);
  sub_804B1E7();
  v0 = fopen((const char *)&stream.__pad1, "rb");
  v2 = v0;
  if ( v0 )
  {
    if ( fread(&ptr, 0x10u, 1u, v0) && !memcmp(&ptr, "HUST", 4u) )
    {
      dword_8051608 = (*(_DWORD *)&ptr ^ v9) + 16;
      fseek(v2, 0, 2);
      dword_8051460 = ftell(v2);
      fclose(v2);
      v1 = dword_8051608;
      if ( dword_8051608 > 15 )
      {
        v3 = (signed int)(dword_8051460 - dword_8051608) / 2;
        v1 = v3 + 23;
        dword_8051460 = v3 + 23;
        if ( (unsigned int)(v3 - 105) <= 0x317 )
        {
          dword_8051464 += 2;
          goto LABEL_12;
        }
      }
    }
    else
    {
      fclose(v2);
    }
  }
  if ( *((_BYTE *)&stream._offset + strlen((const char *)&stream.__pad1) + 7) != 47 )
  {
    v4 = v1;
    v5 = dcgettext(0, "!! %s\n", 5);
    __printf_chk(1, v5, &stream.__pad1, v4);
  }
  dword_8051460 = (unsigned int)dword_8051464 < 1 ? 128 : 471;
LABEL_12:
  dword_805145C = (size_t)malloc(dword_8051460);
  result = *MK_FP(__GS__, 20) ^ v10;
  if ( *MK_FP(__GS__, 20) != v10 )
    __stack_chk_fail(v6);
  return result;
}
// 8048DBC: using guessed type int __printf_chk(_DWORD, const char *, ...);
// 8048FCC: using guessed type int __fastcall __stack_chk_fail(_DWORD);
// 804B1E7: using guessed type int sub_804B1E7(void);
// 8051464: using guessed type int dword_8051464;
// 8051608: using guessed type int dword_8051608;

//----- (0804B3FF) --------------------------------------------------------
_UNKNOWN *__cdecl sub_804B3FF(int a1, signed int a2)
{
  signed int v2; // ebx@1
  _UNKNOWN *v3; // edi@3
  signed int v4; // esi@3
  int v5; // eax@4
  _UNKNOWN *v6; // ST00_4@4
  _UNKNOWN *result; // eax@6

  v2 = a2;
  if ( a2 > 128 )
    v2 = 128;
  v3 = &unk_8051474;
  v4 = 0;
  while ( v4 < v2 )
  {
    v5 = *(_BYTE *)(a1 + v4++);
    v6 = v3;
    v3 = (char *)v3 + 3;
    __sprintf_chk(v6, 1, -1, "%02x:", v5);
  }
  result = &unk_8051474;
  *((_BYTE *)&dword_8051470 + 3 * v2 + 3) = 0;
  return result;
}
// 804906C: using guessed type int __sprintf_chk(_DWORD, _DWORD, _DWORD, const char *, ...);
// 8051470: using guessed type int dword_8051470;

//----- (0804B45D) --------------------------------------------------------
signed int __usercall sub_804B45D<eax>(int a1<eax>)
{
  int v1; // esi@1
  int v2; // ebx@1
  int v3; // edi@1
  char *v4; // eax@1
  _UNKNOWN *v5; // ebx@1
  char *v6; // eax@1
  char *v7; // eax@2
  int v8; // ecx@2
  signed int result; // eax@2
  char *v10; // eax@3
  char v11; // [sp+Fh] [bp-9Dh]@3
  int v12; // [sp+90h] [bp-1Ch]@1

  v1 = a1;
  v12 = *MK_FP(__GS__, 20);
  v2 = *(_BYTE *)(dword_805145C + 59);
  v3 = *(_BYTE *)(dword_805145C + 60);
  v4 = dcgettext(0, "** :\t%d.%d\n", 5);
  __printf_chk(1, v4, v2, v3);
  v5 = sub_804B3FF(v1, 16);
  v6 = dcgettext(0, "** MD5:\t%s\n", 5);
  __printf_chk(1, v6, v5);
  if ( sub_804A5CA((const char *)&stream.__pad1) == -1 )
  {
    v7 = dcgettext(0, "!! 8021x.exe\n", 5);
    __printf_chk(1, v7);
    result = 1;
  }
  else
  {
    sub_804A30D((const void *)v1, (int)&v11);
    v10 = dcgettext(0, "** V2:\t%s\n", 5);
    __printf_chk(1, v10, &v11, v5);
    sub_804AEA3(23, &v11, 0x20u);
    sub_804A166();
    result = 0;
  }
  if ( *MK_FP(__GS__, 20) != v12 )
    __stack_chk_fail(v8);
  return result;
}
// 8048DBC: using guessed type int __printf_chk(_DWORD, const char *, ...);
// 8048FCC: using guessed type int __fastcall __stack_chk_fail(_DWORD);

//----- (0804B557) --------------------------------------------------------
signed int __cdecl sub_804B557(int a1)
{
  signed int result; // eax@2

  if ( dword_8051464 > 1 )
  {
    if ( sub_804AFA5(1) != -1 )
    {
LABEL_6:
      result = sub_804B45D(a1);
      goto LABEL_7;
    }
    result = sub_804B557(a1);
  }
  else
  {
    result = sub_804B0FE();
    if ( dword_8051464 == 1 )
      goto LABEL_6;
  }
LABEL_7:
  dword_8051470 = 4139;
  return result;
}
// 804B557: using guessed type _DWORD __cdecl sub_804B557(_DWORD);
// 8051464: using guessed type int dword_8051464;
// 8051470: using guessed type int dword_8051470;

//----- (0804B5AB) --------------------------------------------------------
_UNKNOWN *__cdecl sub_804B5AB(int a1)
{
  __sprintf_chk(&unk_80515F8, 1, 16, "%d.%d.%d.%d", (unsigned __int8)a1, BYTE1(a1), BYTE2(a1), BYTE3(a1));
  return &unk_80515F8;
}
// 804906C: using guessed type int __sprintf_chk(_DWORD, _DWORD, _DWORD, const char *, ...);

//----- (0804B5DF) --------------------------------------------------------
signed int __usercall sub_804B5DF<eax>(int a1<edi>, int a2<esi>)
{
  int v2; // ecx@1
  int v3; // ebx@1
  char *v4; // eax@2
  int v5; // ecx@3
  __int16 v6; // ax@5
  int v7; // edx@9
  int v8; // ST0C_4@10
  char *v9; // eax@10
  char *v10; // eax@20
  char *v11; // eax@22
  _UNKNOWN *v12; // ebx@22
  char *v13; // eax@22
  _UNKNOWN *v14; // ebx@22
  char *v15; // eax@22
  size_t v16; // ecx@22
  size_t v17; // edi@22
  int v18; // ecx@28
  signed int result; // eax@28
  char *v20; // [sp-4h] [bp-50h]@2
  int v21; // [sp+0h] [bp-4Ch]@2
  char v22; // [sp+10h] [bp-3Ch]@3
  int v23; // [sp+22h] [bp-2Ah]@4
  __int16 v24; // [sp+26h] [bp-26h]@4
  int v25; // [sp+30h] [bp-1Ch]@1

  v25 = *MK_FP(__GS__, 20);
  v3 = socket(2, 2, 0);
  if ( v3 < 0 )
  {
    v21 = v2;
    v4 = dcgettext(0, "!! !\n", 5);
LABEL_28:
    __printf_chk(1, v4, v20, v21);
    result = -1;
    goto LABEL_31;
  }
  __strcpy_chk(&v22, &stream._cur_column, 16);
  if ( ioctl(v3, 0x8927u, &v22, a2) < 0 )
  {
    close(v3);
    v4 = dcgettext(0, "!! %sMAC!\n", 5);
    v20 = (char *)&stream._cur_column;
    goto LABEL_28;
  }
  dword_8051A64 = v23;
  word_8051A68 = v24;
  if ( !dword_8051A14 )
  {
    dword_8051A5C = dword_804EA04;
    v6 = dword_804EA08;
LABEL_8:
    word_8051A60 = v6;
    goto LABEL_9;
  }
  if ( dword_8051A14 == 1 )
  {
    dword_8051A5C = dword_804EA0C;
    v6 = dword_804EA10;
    goto LABEL_8;
  }
LABEL_9:
  LOBYTE(dword_8051A54) = -2;
  if ( ioctl(v3, 0x8915u, &v22, v5) >= 0 )
  {
    dword_8051468 = *(int *)((char *)&v23 + 2);
    if ( dword_8051A08 && (dword_8051A14 % 3u != 2 || BYTE3(dword_8051A08) != 2) )
      LOBYTE(dword_8051A54) = -1;
  }
  else
  {
    v8 = v7;
    v9 = dcgettext(0, "!! %sIP!\n", 5);
    __printf_chk(1, v9, &stream._cur_column, v8);
  }
  if ( (dword_8051A18 || dword_8051A00 == -1) && (dword_8051A00 = dword_8051468, dword_8051A18) || dword_8051A04 == -1 )
  {
    if ( ioctl(v3, 0x891Bu, &v22, dword_8051A18) >= 0 )
    {
      dword_8051A04 = *(int *)((char *)&v23 + 2);
    }
    else
    {
      v10 = dcgettext(0, "!! %s!\n", 5);
      __printf_chk(1, v10, &stream._cur_column, a1);
    }
  }
  close(v3);
  sub_804B3FF((int)&dword_8051A64, 6);
  v11 = dcgettext(0, "** MAC:\t%s\n", 5);
  __printf_chk(1, v11);
  v12 = sub_804B5AB(dword_8051A00);
  v13 = dcgettext(0, "** IP:\t%s\n", 5);
  __printf_chk(1, v13, v12);
  v14 = sub_804B5AB(dword_8051A04);
  v15 = dcgettext(0, "** :\t%s\n", 5);
  __printf_chk(1, v15, v14);
  v16 = dword_8051460;
  v17 = dword_805145C;
  while ( v16 )
  {
    *(_BYTE *)v17++ = 0;
    --v16;
  }
  *(_BYTE *)(dword_805145C + 2) = 19;
  *(_BYTE *)(dword_805145C + 3) = 17;
  if ( dword_8051A18 )
    *(_BYTE *)(dword_805145C + 4) = 1;
  *(_DWORD *)(dword_805145C + 5) = dword_8051A00;
  *(_DWORD *)(dword_805145C + 9) = dword_8051A04;
  *(_DWORD *)(dword_805145C + 13) = dword_8051A08;
  *(_DWORD *)(dword_805145C + 17) = dword_8051A0C;
  sub_804ACF0(dword_805145C);
  result = 0;
LABEL_31:
  if ( *MK_FP(__GS__, 20) != v25 )
    __stack_chk_fail(v18);
  return result;
}
// 8048DBC: using guessed type int __printf_chk(_DWORD, const char *, ...);
// 8048F7C: using guessed type int __cdecl __strcpy_chk(_DWORD, _DWORD, _DWORD);
// 8048FCC: using guessed type int __fastcall __stack_chk_fail(_DWORD);
// 804EA04: using guessed type int dword_804EA04;
// 804EA08: using guessed type int dword_804EA08;
// 804EA0C: using guessed type int dword_804EA0C;
// 804EA10: using guessed type int dword_804EA10;
// 8051468: using guessed type int dword_8051468;
// 8051A00: using guessed type int dword_8051A00;
// 8051A04: using guessed type int dword_8051A04;
// 8051A08: using guessed type int dword_8051A08;
// 8051A0C: using guessed type int dword_8051A0C;
// 8051A14: using guessed type int dword_8051A14;
// 8051A18: using guessed type int dword_8051A18;
// 8051A54: using guessed type int dword_8051A54;
// 8051A5C: using guessed type int dword_8051A5C;
// 8051A60: using guessed type __int16 word_8051A60;
// 8051A64: using guessed type int dword_8051A64;
// 8051A68: using guessed type __int16 word_8051A68;

//----- (0804B8C6) --------------------------------------------------------
char *__cdecl sub_804B8C6(char *inbuf, size_t inbytesleft)
{
  char *v2; // ebx@1
  size_t v3; // esi@1
  iconv_t v4; // edi@1
  size_t v5; // ST2C_4@2
  void *v6; // ST10_4@3
  char *outbuf; // [sp+20h] [bp-20h]@2
  size_t cd; // [sp+24h] [bp-1Ch]@1

  v2 = 0;
  v3 = (3 * inbytesleft >> 1) + 1;
  cd = (3 * inbytesleft >> 1) + 1;
  v4 = iconv_open("utf-8", "gbk");
  if ( v4 != (iconv_t)-1 )
  {
    outbuf = (char *)malloc(v3);
    v2 = outbuf;
    v5 = iconv(v4, &inbuf, &inbytesleft, &outbuf, &cd);
    iconv_close(v4);
    if ( v5 == -1 )
    {
      v6 = v2;
      v2 = 0;
      free(v6);
    }
    else
    {
      v2[v3 - cd] = 0;
    }
  }
  return v2;
}

//----- (0804B950) --------------------------------------------------------
int __cdecl sub_804B950(const char *filename)
{
  char *v1; // eax@2
  int v2; // ST08_4@2
  int v3; // ecx@2
  signed int v4; // ecx@3
  int *v5; // edi@3
  char v6; // zf@5
  char *v7; // eax@6
  void *v8; // ebx@6
  int result; // eax@8
  int inbuf; // [sp+10h] [bp-80Ch]@1
  int v11; // [sp+810h] [bp-Ch]@1

  v11 = *MK_FP(__GS__, 20);
  if ( sub_804A58B(filename, (unsigned int)&inbuf, 2048) )
  {
    v1 = dcgettext(0, "!! SuConfig.dat\n", 5);
    ((void (__cdecl *)(signed int, char *, int, int *))__printf_chk)(1, v1, v2, &inbuf);
  }
  else
  {
    v4 = -1;
    v5 = &inbuf;
    do
    {
      if ( !v4 )
        break;
      v6 = *(_BYTE *)v5 == 0;
      v5 = (int *)((char *)v5 + 1);
      --v4;
    }
    while ( !v6 );
    v7 = sub_804B8C6((char *)&inbuf, ~v3 - 1);
    v8 = v7;
    if ( v7 )
    {
      __printf_chk(1, "%s\n", v7, v5);
      free(v8);
    }
  }
  result = *MK_FP(__GS__, 20) ^ v11;
  if ( *MK_FP(__GS__, 20) != v11 )
    __stack_chk_fail(v3);
  return result;
}
// 8048DBC: using guessed type int __printf_chk(_DWORD, const char *, ...);
// 8048FCC: using guessed type int __fastcall __stack_chk_fail(_DWORD);

//----- (0804B9EB) --------------------------------------------------------
signed int __fastcall sub_804B9EB(int a1)
{
  signed int v1; // edx@1
  int v2; // eax@2
  int v3; // esi@2
  int v4; // edi@3
  int v5; // eax@5
  char *v6; // eax@11
  signed int result; // eax@14
  struct pollfd fds; // [sp+4h] [bp-74h]@3
  char buf; // [sp+Ch] [bp-6Ch]@1
  struct sockaddr addr; // [sp+4Ch] [bp-2Ch]@2
  int v11; // [sp+5Ch] [bp-1Ch]@1

  v1 = 0;
  v11 = *MK_FP(__GS__, 20);
  memcpy(&buf, &unk_804EA14, 0x40u);
  if ( dword_8051A10 )
  {
    LOBYTE(a1) = 4;
    memset(&addr, 0, 4 * a1);
    addr.sa_family = 2;
    *(_DWORD *)&addr.sa_data[2] = dword_8051A10;
    v2 = socket(2, 3, 1);
    v3 = v2;
    if ( v2 >= 0 )
    {
      fds.fd = v2;
      v4 = 1000;
      fds.events = 1;
      while ( sendto(v3, &buf, 0x40u, 0, &addr, 0x10u) >= 0 )
      {
        v5 = poll(&fds, 1u, v4);
        if ( v5 == -1 )
          break;
        if ( v5 > 0 )
        {
          close(v3);
          v1 = 0;
          goto LABEL_14;
        }
        v4 += 1000;
        if ( v4 == 4000 )
        {
          close(v3);
          v1 = -1;
          goto LABEL_14;
        }
      }
    }
    v6 = dcgettext(0, "!! Ping", 5);
    perror(v6);
    if ( v3 != -1 )
      close(v3);
    dword_8051A10 = 0;
    v1 = 0;
  }
LABEL_14:
  result = v1;
  if ( *MK_FP(__GS__, 20) != v11 )
    __stack_chk_fail(*MK_FP(__GS__, 20) ^ v11);
  return result;
}
// 8048FCC: using guessed type int __fastcall __stack_chk_fail(_DWORD);
// 8051A10: using guessed type int dword_8051A10;

//----- (0804BB0C) --------------------------------------------------------
int __usercall sub_804BB0C<eax>(__time_t a1<eax>)
{
  struct itimerval new; // [sp+4h] [bp-18h]@1

  new.it_value.tv_sec = a1;
  new.it_interval.tv_sec = a1;
  new.it_value.tv_usec = 0;
  new.it_interval.tv_usec = 0;
  return setitimer(0, &new, 0);
}

//----- (0804BB38) --------------------------------------------------------
int __cdecl sub_804BB38()
{
  if ( (unsigned int)dword_8051A14 > 2 )
    dword_8051A14 -= 3;
  dword_805160C = 1;
  dword_8051614 = -1;
  sub_804BB0C(dword_80513D8);
  return 0;
}
// 80513D8: using guessed type int dword_80513D8;
// 805160C: using guessed type int dword_805160C;
// 8051614: using guessed type int dword_8051614;
// 8051A14: using guessed type int dword_8051A14;

//----- (0804BB72) --------------------------------------------------------
__int16 __usercall sub_804BB72<ax>(unsigned int a1<eax>)
{
  __int16 result; // ax@1

  memset(&dword_8051618, 0, 0x3E8u);
  dword_8051624 = _byteswap_ulong(a1);
  dword_8051618 = dword_8051A5C;
  word_805161C = word_8051A60;
  dword_805161E = dword_8051A64;
  result = word_8051A68;
  word_8051622 = word_8051A68;
  return result;
}
// 8051618: using guessed type int dword_8051618;
// 805161C: using guessed type __int16 word_805161C;
// 805161E: using guessed type int dword_805161E;
// 8051622: using guessed type __int16 word_8051622;
// 8051624: using guessed type int dword_8051624;
// 8051A5C: using guessed type int dword_8051A5C;
// 8051A60: using guessed type __int16 word_8051A60;
// 8051A64: using guessed type int dword_8051A64;
// 8051A68: using guessed type __int16 word_8051A68;

//----- (0804BBC1) --------------------------------------------------------
int __usercall sub_804BBC1<eax>(int a1<ecx>, int *a2<ebx>, int a3<edi>, signed int a4)
{
  signed int v4; // eax@1
  int v5; // esi@5
  char *v6; // eax@15
  char *v7; // eax@13
  int result; // eax@17
  char *v9; // eax@19
  int v10; // ST14_4@19
  int v11; // esi@19
  char *v12; // eax@19
  unsigned int v13; // eax@25
  char *v14; // eax@27
  char *v15; // edi@27
  signed int v16; // ecx@27
  char *v17; // eax@32
  unsigned int v18; // ebx@33
  char *v19; // eax@35
  __int16 v20; // ax@35
  int v21; // eax@36
  int v22; // ebx@36
  char *v23; // edi@38
  char *v24; // eax@38
  signed int v25; // ecx@38
  char v26; // zf@40
  signed int v27; // ebx@41
  __int16 v28; // ax@41
  void *v29; // eax@41
  int v30; // ebx@42
  char *v31; // eax@44
  __int16 v32; // ax@44
  char v33; // dl@44
  const void *v34; // esi@44
  char *v35; // eax@48
  __int16 v36; // ax@48
  char v37; // dl@48
  size_t v38; // esi@49
  size_t v39; // ecx@49
  char *v40; // eax@57
  signed int v41; // ecx@63
  int *v42; // edi@63
  signed int v43; // ecx@67
  char *v44; // edi@68
  char *v45; // eax@73
  signed int v46; // ecx@75
  char *v47; // edi@76
  signed int v48; // [sp-10h] [bp-78h]@22
  const char *v49; // [sp-Ch] [bp-74h]@10
  int v50; // [sp-8h] [bp-70h]@10
  signed int v51; // [sp-8h] [bp-70h]@46
  int *v52; // [sp-4h] [bp-6Ch]@0
  unsigned int v53; // [sp+Ch] [bp-5Ch]@42
  int v54; // [sp+10h] [bp-58h]@61
  __int16 v55; // [sp+14h] [bp-54h]@62
  int v56; // [sp+16h] [bp-52h]@62
  __int16 v57; // [sp+1Ah] [bp-4Eh]@62
  char v58; // [sp+1Ch] [bp-4Ch]@61
  char v59; // [sp+1Dh] [bp-4Bh]@61
  char v60; // [sp+1Fh] [bp-49h]@61
  char v61; // [sp+20h] [bp-48h]@61
  char v62; // [sp+22h] [bp-46h]@61
  char v63; // [sp+23h] [bp-45h]@61
  char v64; // [sp+25h] [bp-43h]@62
  int v65; // [sp+26h] [bp-42h]@62
  __int16 v66; // [sp+2Ah] [bp-3Eh]@62
  int v67; // [sp+2Ch] [bp-3Ch]@62
  int v68; // [sp+30h] [bp-38h]@62
  __int16 v69; // [sp+34h] [bp-34h]@62
  int v70; // [sp+36h] [bp-32h]@62
  int v71; // [sp+4Ch] [bp-1Ch]@1

  v4 = a4;
  v71 = *MK_FP(__GS__, 20);
  while ( 2 )
  {
    while ( 1 )
    {
      if ( dword_805160C == v4 )
      {
        ++dword_8051614;
      }
      else
      {
        dword_805160C = v4;
        dword_8051614 = 0;
      }
      v5 = dword_8051614;
      if ( v4 == 4 )
        break;
      if ( dword_8051614 <= 2 )
        break;
      if ( v4 == 2 )
      {
        v50 = 5;
        v49 = ">> !\n";
        goto LABEL_15;
      }
      if ( v4 <= 2 )
      {
        if ( v4 != 1 )
        {
LABEL_17:
          result = sub_804BB38();
          goto LABEL_86;
        }
        v50 = 5;
        v49 = ">> !\n";
LABEL_15:
        v6 = dcgettext(0, v49, v50);
        __printf_chk(1, v6);
        goto LABEL_17;
      }
      if ( v4 == 3 )
      {
        v50 = 5;
        v49 = ">> !\n";
        goto LABEL_15;
      }
      if ( v4 != 6 )
        goto LABEL_17;
      v52 = a2;
      v7 = dcgettext(0, ">> !\n", 5);
      __printf_chk(1, v7);
      v4 = 4;
    }
    switch ( v4 )
    {
      case 5:
        sub_804BB0C(0);
        v9 = dcgettext(0, ">> IP...\n", 5);
        v11 = v10;
        __printf_chk(1, v9);
        system(&domainname);
        v12 = dcgettext(0, ">> \n", 5);
        __printf_chk(1, v12);
        dword_8051A18 += 3;
        if ( sub_804B5DF(a3, v11) == -1 )
          exit(1);
        if ( dword_8051A18 == 5 )
          v48 = 4;
        else
          v48 = 1;
        result = sub_804BBC1(v48);
        goto LABEL_86;
      case 1:
        v13 = dword_8051A14 / 3u;
        if ( dword_8051A14 % 3u == 2 )
        {
          if ( !dword_8051614 )
          {
            v14 = dcgettext(0, ">> ...\n", 5);
            __printf_chk(1, v14);
            v15 = &byte_805162A;
            v16 = 42;
            dword_8051624 = 16879240;
            word_8051628 = 0;
            dword_8051618 = dword_804EA04;
            word_805161C = dword_804EA08;
            dword_805161E = dword_8051A64;
            word_8051622 = word_8051A68;
            while ( v16 )
            {
              *v15++ = -91;
              --v16;
            }
            v13 = sub_804BB0C(dword_80513D0);
          }
          goto LABEL_79;
        }
        if ( dword_8051614 )
          goto LABEL_51;
        v17 = dcgettext(0, ">> ...\n", 5);
        __printf_chk(1, v17);
        sub_804B0FE();
        sub_804BB72(0x888E0101u);
        __memcpy_chk(&byte_805162A, dword_805145C, dword_8051460, 982);
        goto LABEL_50;
      case 2:
        v18 = strlen(&byte_8051138);
        if ( dword_8051A14 % 3u == 2 )
        {
          if ( !dword_8051614 )
          {
            v19 = dcgettext(0, ">> ...\n", 5);
            __printf_chk(1, v19);
            v20 = __ROR__(v18 + 30, 8);
            HIWORD(dword_8051624) = 1;
            word_805162C = v20;
            word_8051628 = v20;
            byte_805162A = 2;
            byte_805162E[0] = 1;
            byte_805162F = 1;
            sub_804AE79((int)&dword_8051618);
            dword_8051640 = 808334128;
            dword_8051644 = 892350002;
            __memcpy_chk(&unk_8051648, &byte_8051138, v18, 952);
            sub_804BB0C(dword_80513D0);
          }
          v21 = dword_8051610;
          v22 = v18 + 48;
          byte_805162B = *(_BYTE *)(dword_8051610 + 19);
          LOBYTE(v21) = byte_805162B;
          v52 = (int *)v21;
          goto LABEL_46;
        }
        if ( dword_8051614 )
          goto LABEL_51;
        v23 = &byte_8051138;
        v24 = dcgettext(0, ">> ...\n", 5);
        __printf_chk(1, v24);
        sub_804BB72(0x888E0100u);
        v25 = -1;
        do
        {
          if ( !v25 )
            break;
          v26 = *v23++ == 0;
          --v25;
        }
        while ( !v26 );
        byte_805162A = 2;
        v27 = ~v25;
        v28 = __ROR__(~(_WORD)v25 - 1 + 5, 8);
        word_8051628 = v28;
        word_805162C = v28;
        byte_805162B = *(_BYTE *)(dword_8051610 + 19);
        byte_805162E[0] = 1;
        __memcpy_chk(&byte_805162F, &byte_8051138, ~v25 - 1, 977);
        v29 = &byte_805162E[v27];
        goto LABEL_49;
      case 3:
        v53 = strlen(&byte_8051138) + 1;
        v30 = v53 - 1;
        if ( dword_8051A14 % 3u == 2 )
        {
          if ( !dword_8051614 )
          {
            v31 = dcgettext(0, ">> ...\n", 5);
            __printf_chk(1, v31);
            v32 = __ROR__(v30 + 22, 8);
            word_805162C = v32;
            word_8051628 = v32;
            HIWORD(dword_8051624) = 1;
            byte_805162A = 2;
            v33 = *(_BYTE *)(dword_8051610 + 19);
            byte_805162E[0] = 4;
            byte_805162F = 16;
            byte_805162B = v33;
            v34 = sub_804AEFB(
                    *(_BYTE *)(dword_8051610 + 19),
                    (const void *)(dword_8051610 + 24),
                    *(_BYTE *)(dword_8051610 + 23));
            memcpy(&unk_8051630, v34, 0x10u);
            v5 = (int)((char *)v34 + 16);
            __memcpy_chk(&dword_8051640, &byte_8051138, v30, 960);
            sub_804BB0C(dword_80513D0);
          }
          v22 = v30 + 40;
          v52 = (int *)v5;
LABEL_46:
          v51 = v22;
          goto LABEL_81;
        }
        if ( !dword_8051614 )
        {
          v35 = dcgettext(0, ">> ...\n", 5);
          __printf_chk(1, v35);
          sub_804B557(dword_8051610 + 24);
          sub_804BB72(0x888E0100u);
          v36 = __ROR__(v30 + 22, 8);
          word_8051628 = v36;
          word_805162C = v36;
          byte_805162A = 2;
          v37 = *(_BYTE *)(dword_8051610 + 19);
          byte_805162E[0] = 4;
          byte_805162F = 16;
          byte_805162B = v37;
          memcpy(
            &unk_8051630,
            sub_804AEFB(
              *(_BYTE *)(dword_8051610 + 19),
              (const void *)(dword_8051610 + 24),
              *(_BYTE *)(dword_8051610 + 23)),
            0x10u);
          __memcpy_chk(&dword_8051640, &byte_8051138, v30, 960);
          v29 = (char *)&unk_805163F + v53;
LABEL_49:
          v38 = dword_805145C;
          v39 = dword_8051460;
          memcpy(v29, (const void *)dword_805145C, dword_8051460);
          v5 = v38 + v39;
LABEL_50:
          sub_804BB0C(dword_80513D0);
        }
LABEL_51:
        v52 = (int *)v5;
        goto LABEL_84;
      case 6:
        if ( !dword_8051614 )
          sub_804BB0C(dword_80513D4);
        goto LABEL_85;
      case 4:
        if ( !dword_8051A10
          || (v5 = dword_80513D4 * dword_8051614, (unsigned int)(dword_80513D4 * dword_8051614) <= 0x3C) )
          goto LABEL_60;
        if ( sub_804B9EB(a1) == -1 )
        {
          v52 = a2;
          v40 = dcgettext(0, ">> !\n", 5);
          __printf_chk(1, v40);
          v4 = 1;
          continue;
        }
        dword_8051614 = 1;
LABEL_60:
        if ( (_BYTE)dword_8051A54 != -2 )
        {
          memset(&v54, 0, 0x3Cu);
          v58 = 8;
          v59 = 6;
          v60 = 1;
          v61 = 8;
          v62 = 6;
          v63 = 4;
          if ( (_BYTE)dword_8051A54 != -1 )
          {
            v5 = (int)&v54;
            v55 = word_8051A58;
            v57 = word_8051A68;
            v66 = word_8051A68;
            v69 = word_8051A58;
            v54 = dword_8051A54;
            v56 = dword_8051A64;
            v64 = 2;
            v65 = dword_8051A64;
            v67 = dword_8051468;
            v68 = dword_8051A54;
            v70 = dword_8051A08;
            dword_8051A28(status, &v54, 60, &v71);
          }
          v41 = 6;
          a2 = &v54;
          v54 = -1;
          v55 = -1;
          v57 = word_8051A68;
          v66 = word_8051A68;
          v56 = dword_8051A64;
          v65 = dword_8051A64;
          v42 = &v68;
          v67 = dword_8051468;
          while ( v41 )
          {
            *(_BYTE *)v42 = 0;
            v42 = (int *)((char *)v42 + 1);
            --v41;
          }
          v64 = 1;
          v70 = dword_8051A08;
          dword_8051A28(status, &v54, 42, v5);
        }
        v43 = 3;
        if ( dword_8051A14 % 3u == 2 )
        {
          v44 = &byte_805162A;
          LOBYTE(v43) = 42;
          HIWORD(dword_8051624) = 1537;
          word_8051628 = 0;
          while ( v43 )
          {
            *v44++ = -91;
            --v43;
          }
          sub_804BBC1(6);
LABEL_80:
          v51 = 60;
        }
        else
        {
          if ( !dword_8051614 )
          {
            memcpy(&v54, &unk_804EFEC, 0x1Du);
            v52 = a2;
            v45 = dcgettext(0, ">> ...\n", 5);
            __printf_chk(1, v45);
            sub_804BB72(0x888E01BFu);
            memcpy(&word_8051628, &v54, 0x1Du);
            sub_804BB0C(dword_80513D4);
          }
          sub_804ADE0((int)&dword_8051618);
          v51 = 45;
        }
LABEL_81:
        result = dword_8051A28(status, &dword_8051618, v51, v52);
LABEL_86:
        if ( *MK_FP(__GS__, 20) != v71 )
          __stack_chk_fail(a1);
        return result;
      case 0:
        sub_804BB0C(0);
        v46 = 3;
        v13 = dword_8051A14 / 3u;
        if ( dword_8051A14 % 3u == 2 )
        {
          LOBYTE(v46) = 42;
          LOBYTE(v13) = -91;
          v47 = &byte_805162A;
          HIWORD(dword_8051624) = 513;
          word_8051628 = 0;
          while ( v46 )
          {
            *v47++ = -91;
            --v46;
          }
LABEL_79:
          v52 = (int *)v13;
          goto LABEL_80;
        }
        sub_804B0FE();
        sub_804BB72(0x888E0102u);
        __memcpy_chk(&byte_805162A, dword_805145C, dword_8051460, 982);
LABEL_84:
        v51 = 1000;
        goto LABEL_81;
      default:
LABEL_85:
        result = 0;
        goto LABEL_86;
    }
  }
}
// 8051A28: invalid function type has been ignored
// 8048DBC: using guessed type int __printf_chk(_DWORD, const char *, ...);
// 8048E3C: using guessed type int __cdecl __memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD);
// 8048FCC: using guessed type int __fastcall __stack_chk_fail(_DWORD);
// 804B557: using guessed type _DWORD __cdecl sub_804B557(_DWORD);
// 804EA04: using guessed type int dword_804EA04;
// 804EA08: using guessed type int dword_804EA08;
// 80513D0: using guessed type int dword_80513D0;
// 80513D4: using guessed type int dword_80513D4;
// 8051468: using guessed type int dword_8051468;
// 805160C: using guessed type int dword_805160C;
// 8051610: using guessed type int dword_8051610;
// 8051614: using guessed type int dword_8051614;
// 8051618: using guessed type int dword_8051618;
// 805161C: using guessed type __int16 word_805161C;
// 805161E: using guessed type int dword_805161E;
// 8051622: using guessed type __int16 word_8051622;
// 8051624: using guessed type int dword_8051624;
// 8051628: using guessed type __int16 word_8051628;
// 805162A: using guessed type char byte_805162A;
// 805162B: using guessed type char byte_805162B;
// 805162C: using guessed type __int16 word_805162C;
// 805162F: using guessed type char byte_805162F;
// 8051640: using guessed type int dword_8051640;
// 8051644: using guessed type int dword_8051644;
// 8051A08: using guessed type int dword_8051A08;
// 8051A10: using guessed type int dword_8051A10;
// 8051A14: using guessed type int dword_8051A14;
// 8051A18: using guessed type int dword_8051A18;
// 8051A28: using guessed type int (__cdecl *dword_8051A28)(_DWORD, _DWORD, _DWORD, _DWORD);
// 8051A54: using guessed type int dword_8051A54;
// 8051A58: using guessed type __int16 word_8051A58;
// 8051A64: using guessed type int dword_8051A64;
// 8051A68: using guessed type __int16 word_8051A68;

//----- (0804C3BC) --------------------------------------------------------
#error "804C4D4: positive sp value has been found (funcsize=91)"

//----- (0804C4D5) --------------------------------------------------------
bool __cdecl sub_804C4D5(int a1)
{
  char *v1; // eax@3
  int v2; // ecx@3
  bool result; // eax@3
  int v4; // ebx@5
  char *v5; // eax@8
  struct termios termios_p; // [sp+8h] [bp-48h]@1
  int v7; // [sp+44h] [bp-Ch]@1

  v7 = *MK_FP(__GS__, 20);
  if ( !tcgetattr(0, &termios_p) )
  {
    termios_p.c_lflag &= 0xFFFFFF87u;
    if ( tcsetattr(0, 2, &termios_p) )
    {
LABEL_3:
      v1 = dcgettext(0, "", 5);
      perror(v1);
      result = -2;
      goto LABEL_11;
    }
    v4 = 0;
    if ( a1 )
      v4 = __isoc99_scanf("%s", a1, 0, 0);
    if ( !tcgetattr(0, &termios_p) )
    {
      termios_p.c_lflag |= 0x78u;
      if ( !tcsetattr(0, 2, &termios_p) )
      {
        result = v4 < 0;
        LOBYTE(result) = v4 <= 0;
        goto LABEL_11;
      }
      goto LABEL_3;
    }
  }
  v5 = dcgettext(0, "", 5);
  perror(v5);
  result = -1;
LABEL_11:
  if ( *MK_FP(__GS__, 20) != v7 )
    __stack_chk_fail(v2);
  return result;
}
// 8048FCC: using guessed type int __fastcall __stack_chk_fail(_DWORD);
// 804900C: using guessed type int __isoc99_scanf(const char *, ...);

//----- (0804C5B1) --------------------------------------------------------
signed int __usercall sub_804C5B1<eax>(int a1<ebx>)
{
  int v1; // ecx@1
  int v2; // esi@2
  char *v3; // eax@3
  int v4; // edi@4
  int v5; // ebx@4
  int v6; // eax@6
  char *v7; // eax@7
  int v8; // ecx@11
  signed int result; // eax@11
  int v10; // edi@12
  int v11; // ST1C_4@13
  char *v12; // eax@13
  int v13; // ebx@17
  char *v14; // eax@17
  int v15; // edx@17
  signed int i; // eax@17
  const char *v17; // ST14_4@20
  int *v18; // [sp+0h] [bp-140h]@3
  int v19; // [sp+4h] [bp-13Ch]@0
  const char *v20; // [sp+14h] [bp-12Ch]@6
  int v21; // [sp+1Ch] [bp-124h]@7
  int v22; // [sp+20h] [bp-120h]@1
  int v23; // [sp+24h] [bp-11Ch]@1
  int v24; // [sp+124h] [bp-1Ch]@1

  v24 = *MK_FP(__GS__, 20);
  if ( dword_8051A24(&v22, &v23) == -1 || (v2 = v22) == 0 )
  {
    v19 = a1;
    v3 = dcgettext(0, "!! : %s\n", 5);
    v18 = &v23;
LABEL_11:
    __printf_chk(1, v3, v18, v19);
    result = -1;
    goto LABEL_21;
  }
  v4 = 0;
  v5 = 0;
  do
  {
    ++v5;
    if ( !(*(_BYTE *)(v2 + 16) & 1) )
    {
      v19 = v1;
      v20 = *(const char **)(v2 + 4);
      v6 = strcmp(v20, "any");
      if ( v6 )
      {
        v19 = v6;
        ++v4;
        v7 = dcgettext(0, "** [%d]:\t%s\n", 5);
        __printf_chk(1, v7, v5, v20);
        v21 = v5;
      }
    }
    v2 = *(_DWORD *)v2;
  }
  while ( v2 );
  if ( !v4 )
  {
    dword_8051A3C(v22);
    v3 = dcgettext(0, "!! \n", 5);
    goto LABEL_11;
  }
  v10 = v4 - 1;
  if ( v10 )
  {
    v11 = v1;
    v12 = dcgettext(0, "?? [1-%d]: ", 5);
    __printf_chk(1, v12, v5, v11);
    __isoc99_scanf("%d", &v21);
    if ( v21 > 0 )
    {
      if ( v21 > v5 )
        v21 = v5;
    }
    else
    {
      v21 = 1;
    }
  }
  v13 = v21;
  v14 = dcgettext(0, "** [%d]\n", 5);
  __printf_chk(1, v14, v13, v10);
  v15 = v22;
  for ( i = v21; i > 1; --i )
    v15 = *(_DWORD *)v15;
  v17 = *(const char **)(v15 + 4);
  v21 = i;
  strncpy((char *)&stream._cur_column, v17, 0xFu);
  dword_8051A3C(v22);
  result = 0;
LABEL_21:
  if ( *MK_FP(__GS__, 20) != v24 )
    __stack_chk_fail(v8);
  return result;
}
// 8048DBC: using guessed type int __printf_chk(_DWORD, const char *, ...);
// 8048FCC: using guessed type int __fastcall __stack_chk_fail(_DWORD);
// 804900C: using guessed type int __isoc99_scanf(const char *, ...);
// 8051A24: using guessed type int (__cdecl *dword_8051A24)(_DWORD, _DWORD);
// 8051A3C: using guessed type int (__cdecl *dword_8051A3C)(_DWORD);

//----- (0804C762) --------------------------------------------------------
signed int __usercall sub_804C762<eax>(int a1<eax>)
{
  int v1; // edx@1
  unsigned int v2; // kr04_4@1
  signed int result; // eax@1
  int v4; // ecx@1
  int v5; // edi@1
  int i; // esi@2
  int v7; // esi@6
  signed int v8; // eax@6
  unsigned __int8 v9; // bl@12
  int v10; // [sp+Ch] [bp-7Ch]@5
  unsigned __int8 v11; // [sp+10h] [bp-78h]@12
  unsigned __int8 v12; // [sp+23h] [bp-65h]@8
  unsigned __int8 v13; // [sp+24h] [bp-64h]@12
  unsigned __int8 v14; // [sp+25h] [bp-63h]@13
  char v15[70]; // [sp+26h] [bp-62h]@3
  int v16; // [sp+6Ch] [bp-1Ch]@1

  v1 = a1;
  v16 = *MK_FP(__GS__, 20);
  v2 = strlen((const char *)&stream) + 1;
  result = -1;
  v4 = v2 - 1;
  v5 = v2 - 1;
  if ( v2 - 1 <= 0x49 )
  {
    for ( i = 0; i != v4; ++i )
      v15[i] = *((_BYTE *)&stream._flags + i) ^ byte_804FC9C[i];
    v10 = (int)v15;
    while ( v5 > 0 )
    {
      v7 = v5;
      v4 = 0;
      v8 = 0;
      do
      {
        if ( v7 <= 0 )
        {
          *(&v12 + v4) = 0;
        }
        else
        {
          ++v8;
          *(&v12 + v4) = *(_BYTE *)(v10 + v4);
        }
        ++v4;
        --v7;
      }
      while ( v4 != 3 );
      v5 -= 3;
      if ( v8 )
      {
        v9 = v12;
        *(_BYTE *)v1 = byte_804FC58[v12 >> 2];
        v11 = v13;
        v4 = (v13 >> 4) | 16 * (v9 & 3);
        *(_BYTE *)(v1 + 1) = byte_804FC58[v4];
        LOBYTE(v4) = 61;
        if ( v8 != 1 )
        {
          v4 = (v14 >> 6) | 4 * (v11 & 0xF);
          LOBYTE(v4) = byte_804FC58[v4];
        }
        *(_BYTE *)(v1 + 2) = v4;
        LOBYTE(v4) = 61;
        if ( v8 > 2 )
          LOBYTE(v4) = byte_804FC58[v14 & 0x3F];
        *(_BYTE *)(v1 + 3) = v4;
        v1 += 4;
      }
      v10 += 3;
    }
    *(_BYTE *)v1 = 0;
    result = 0;
  }
  if ( *MK_FP(__GS__, 20) != v16 )
    __stack_chk_fail(v4);
  return result;
}
// 8048FCC: using guessed type int __fastcall __stack_chk_fail(_DWORD);
// 804C762: using guessed type char var_62[70];

//----- (0804C890) --------------------------------------------------------
int __usercall sub_804C890<eax>(int a1<eax>)
{
  int v1; // edi@1
  const char *v2; // esi@1
  int v3; // eax@3
  const char *v4; // eax@6
  const char *v5; // eax@6
  const char *v6; // eax@6
  const char *v7; // eax@6
  const char *v8; // eax@6
  int v9; // eax@6
  char *v10; // eax@9
  int v11; // ecx@9
  int result; // eax@9
  const char *v13; // [sp-4h] [bp-A4h]@7
  int v14; // [sp+0h] [bp-A0h]@7
  const char *v15; // [sp+4h] [bp-9Ch]@4
  char *v16; // [sp+4h] [bp-9Ch]@7
  void *stream; // [sp+1Ch] [bp-84h]@1
  char src; // [sp+23h] [bp-7Dh]@6
  char v19; // [sp+24h] [bp-7Ch]@6
  char v20; // [sp+7Ah] [bp-26h]@4
  int v21; // [sp+84h] [bp-1Ch]@1

  v1 = a1;
  v2 = filename;
  v21 = *MK_FP(__GS__, 20);
  if ( sub_804971D(&stream, filename) < 0 )
  {
    stream = malloc(1u);
    *(_BYTE *)stream = 0;
  }
  sub_80492EF((int *)&stream, "MentoHUST", "DhcpScript", &domainname);
  sub_80492EF((int *)&stream, "MentoHUST", "DataFile", (const char *)&::stream.__pad1);
  if ( dword_8051464 )
  {
    __sprintf_chk(&v20, 1, 10, "%u.%u", (unsigned __int8)word_8051A50, HIBYTE(word_8051A50), v3, v3);
    v15 = &v20;
  }
  else
  {
    v15 = "0.00";
  }
  sub_80492EF((int *)&stream, "MentoHUST", "Version", v15);
  sub_80495DC((int *)&stream, "MentoHUST", "ShowNotify", dword_8051134);
  sub_80495DC((int *)&stream, "MentoHUST", "DaemonMode", v1);
  sub_80495DC((int *)&stream, "MentoHUST", "DhcpMode", dword_8051A18);
  sub_80495DC((int *)&stream, "MentoHUST", "StartMode", dword_8051A14);
  sub_80495DC((int *)&stream, "MentoHUST", "MaxFail", dword_80513DC);
  sub_80495DC((int *)&stream, "MentoHUST", "RestartWait", dword_80513D8);
  sub_80495DC((int *)&stream, "MentoHUST", "EchoInterval", dword_80513D4);
  sub_80495DC((int *)&stream, "MentoHUST", "Timeout", dword_80513D0);
  v4 = (const char *)sub_804B5AB(dword_8051A10);
  sub_80492EF((int *)&stream, "MentoHUST", "PingHost", v4);
  v5 = (const char *)sub_804B5AB(dword_8051A0C);
  sub_80492EF((int *)&stream, "MentoHUST", "DNS", v5);
  v6 = (const char *)sub_804B5AB(dword_8051A08);
  sub_80492EF((int *)&stream, "MentoHUST", "Gateway", v6);
  v7 = (const char *)sub_804B5AB(dword_8051A04);
  sub_80492EF((int *)&stream, "MentoHUST", "Mask", v7);
  v8 = (const char *)sub_804B5AB(dword_8051A00);
  sub_80492EF((int *)&stream, "MentoHUST", "IP", v8);
  sub_80492EF((int *)&stream, "MentoHUST", "Nic", (const char *)&::stream._cur_column);
  sub_804C762((int)&v19);
  src = 32;
  sub_80492EF((int *)&stream, "MentoHUST", "Password", &src);
  sub_80492EF((int *)&stream, "MentoHUST", "Username", &byte_8051138);
  v9 = sub_8049184(stream, v2);
  if ( v9 )
  {
    v16 = (char *)v9;
    v14 = 5;
    v13 = "!! %s\n";
  }
  else
  {
    v16 = &src;
    v14 = 5;
    v13 = "** %s.\n";
  }
  v10 = dcgettext(0, v13, v14);
  __printf_chk(1, v10, v2, v16);
  free(stream);
  result = *MK_FP(__GS__, 20) ^ v21;
  if ( *MK_FP(__GS__, 20) != v21 )
    __stack_chk_fail(v11);
  return result;
}
// 8048DBC: using guessed type int __printf_chk(_DWORD, const char *, ...);
// 8048FCC: using guessed type int __fastcall __stack_chk_fail(_DWORD);
// 804906C: using guessed type int __sprintf_chk(_DWORD, _DWORD, _DWORD, const char *, ...);
// 8051134: using guessed type int dword_8051134;
// 80513D0: using guessed type int dword_80513D0;
// 80513D4: using guessed type int dword_80513D4;
// 80513D8: using guessed type int dword_80513D8;
// 80513DC: using guessed type int dword_80513DC;
// 8051464: using guessed type int dword_8051464;
// 8051A00: using guessed type int dword_8051A00;
// 8051A04: using guessed type int dword_8051A04;
// 8051A08: using guessed type int dword_8051A08;
// 8051A0C: using guessed type int dword_8051A0C;
// 8051A10: using guessed type int dword_8051A10;
// 8051A14: using guessed type int dword_8051A14;
// 8051A18: using guessed type int dword_8051A18;
// 8051A50: using guessed type __int16 word_8051A50;

//----- (0804CB6A) --------------------------------------------------------
signed int __usercall sub_804CB6A<eax>(int a1<eax>)
{
  const char *v1; // esi@1
  __int32 v2; // edx@1
  int v3; // ecx@1
  signed int result; // eax@1
  signed int v5; // ecx@3
  unsigned int v6; // eax@3
  int v7; // esi@3
  unsigned int v8; // edx@3
  int v9; // ebx@5
  unsigned int v10; // edi@5
  char v11; // al@10
  signed int v12; // edx@22
  signed int v13; // ebx@32
  int v14; // [sp+10h] [bp-A0h]@1
  int v15; // [sp+14h] [bp-9Ch]@5
  int v16; // [sp+20h] [bp-90h]@29
  int v17; // [sp+24h] [bp-8Ch]@29
  void *stream; // [sp+28h] [bp-88h]@1
  char src; // [sp+2Dh] [bp-83h]@2
  char v20[86]; // [sp+2Eh] [bp-82h]@20
  char dest; // [sp+84h] [bp-2Ch]@28
  int v22; // [sp+94h] [bp-1Ch]@1

  v1 = filename;
  v14 = a1;
  v22 = *MK_FP(__GS__, 20);
  v2 = sub_804971D(&stream, filename);
  result = -1;
  if ( v2 >= 0 )
  {
    sub_804963C((int)stream, "MentoHUST", "Username", "", &byte_8051138, 0x41u);
    sub_804963C((int)stream, "MentoHUST", "Password", "", &src, 0x57u);
    if ( src == 32 )
    {
      v5 = 0;
      v6 = 0;
      v7 = 0;
      v8 = 0;
      while ( 1 )
      {
        LOBYTE(v15) = v20[v7];
        if ( !v20[v7] )
          break;
        if ( (_BYTE)v15 == 61 )
        {
          ++v5;
          if ( v5 > 2 )
            goto LABEL_28;
        }
        else
        {
          v9 = 0;
          v15 = (char)v15;
          v10 = v6;
          while ( 1 )
          {
            v11 = byte_804FC58[v9];
            if ( !v11 )
              break;
            if ( (unsigned __int8)v11 == v15 )
              break;
            ++v9;
          }
          v6 = v10;
          if ( v9 == 64 )
            goto LABEL_28;
          v8 += v9;
        }
        if ( (v7 & 3) == 3 )
        {
          *((_BYTE *)&::stream._flags + v6++) = v8 >> 16;
          if ( v5 > 1 || (*((_BYTE *)&::stream._flags + v6) = BYTE1(v8), ++v6, v5) )
            v5 = 0;
          else
            *((_BYTE *)&::stream._flags + v6++) = v8;
          v8 = 0;
        }
        v8 <<= 6;
        ++v7;
      }
      if ( v6 <= 0x49 )
      {
        v12 = 0;
        if ( !(v7 & 3) )
        {
          while ( v12 < (signed int)v6 )
          {
            *((_BYTE *)&::stream._flags + v12) ^= byte_804FC9C[v12];
            ++v12;
          }
          *((_BYTE *)&::stream._flags + v6) = 0;
        }
      }
    }
    else
    {
      strncpy((char *)&::stream, &src, 0x40u);
      sub_804C762((int)v20);
      src = 32;
      sub_80492EF((int *)&stream, "MentoHUST", "Password", &src);
      sub_8049184(stream, v1);
    }
LABEL_28:
    sub_804963C((int)stream, "MentoHUST", "Nic", "", (char *)&::stream._cur_column, 0x10u);
    sub_804963C((int)stream, "MentoHUST", "Datafile", "", (char *)&::stream.__pad1, 0xFFu);
    sub_804963C((int)stream, "MentoHUST", "DhcpScript", "", &domainname, 0xFFu);
    sub_804963C((int)stream, "MentoHUST", "Version", "", &dest, 0x10u);
    if ( strlen(&dest) > 2 && __isoc99_sscanf(&dest, "%u.%u", &v16, &v17) != -1 && v16 )
    {
      LOBYTE(word_8051A50) = v16;
      dword_8051464 = 1;
      HIBYTE(word_8051A50) = v17;
    }
    sub_804963C((int)stream, "MentoHUST", "IP", "255.255.255.255", &dest, 0x10u);
    dword_8051A00 = inet_addr(&dest);
    sub_804963C((int)stream, "MentoHUST", "Mask", "255.255.255.255", &dest, 0x10u);
    dword_8051A04 = inet_addr(&dest);
    sub_804963C((int)stream, "MentoHUST", "Gateway", "0.0.0.0", &dest, 0x10u);
    dword_8051A08 = inet_addr(&dest);
    sub_804963C((int)stream, "MentoHUST", "DNS", "0.0.0.0", &dest, 0x10u);
    dword_8051A0C = inet_addr(&dest);
    sub_804963C((int)stream, "MentoHUST", "PingHost", "0.0.0.0", &dest, 0x10u);
    v13 = 100;
    dword_8051A10 = inet_addr(&dest);
    dword_80513D0 = sub_80496B3((int)stream, "MentoHUST", "Timeout", 8) % 100;
    dword_80513D4 = sub_80496B3((int)stream, "MentoHUST", "EchoInterval", 30) % 1000;
    LOBYTE(v13) = 4;
    dword_80513D8 = sub_80496B3((int)stream, "MentoHUST", "RestartWait", 15) % 100;
    dword_8051A14 = sub_80496B3((int)stream, "MentoHUST", "StartMode", 0) % 3;
    dword_8051A18 = sub_80496B3((int)stream, "MentoHUST", "DhcpMode", 0) % v13;
    dword_8051134 = sub_80496B3((int)stream, "MentoHUST", "ShowNotify", 5) % 21;
    *(_DWORD *)v14 = sub_80496B3((int)stream, "MentoHUST", "DaemonMode", 0) % v13;
    dword_80513DC = sub_80496B3((int)stream, "MentoHUST", "MaxFail", 8);
    free(stream);
    result = 0;
  }
  if ( *MK_FP(__GS__, 20) != v22 )
    __stack_chk_fail(v3);
  return result;
}
// 8048DAC: using guessed type int __isoc99_sscanf(_DWORD, const char *, ...);
// 8048FCC: using guessed type int __fastcall __stack_chk_fail(_DWORD);
// 8051134: using guessed type int dword_8051134;
// 80513D0: using guessed type int dword_80513D0;
// 80513D4: using guessed type int dword_80513D4;
// 80513D8: using guessed type int dword_80513D8;
// 80513DC: using guessed type int dword_80513DC;
// 8051464: using guessed type int dword_8051464;
// 8051A00: using guessed type int dword_8051A00;
// 8051A04: using guessed type int dword_8051A04;
// 8051A08: using guessed type int dword_8051A08;
// 8051A0C: using guessed type int dword_8051A0C;
// 8051A10: using guessed type int dword_8051A10;
// 8051A14: using guessed type int dword_8051A14;
// 8051A18: using guessed type int dword_8051A18;
// 8051A50: using guessed type __int16 word_8051A50;
// 804CB6A: using guessed type char var_82[86];

//----- (0804D02F) --------------------------------------------------------
int __usercall sub_804D02F<eax>(int a1<ebx>, char a2, int a3)
{
  char *v3; // eax@1
  signed int v4; // esi@1
  char v5; // dl@4
  int v6; // ebx@7
  char *v7; // eax@7
  signed int v8; // ecx@15
  int v9; // edi@15
  char v10; // zf@17
  int v11; // ebx@69
  char *v12; // eax@77
  char *v13; // eax@77
  char *v14; // eax@77
  int v15; // ST10_4@77
  char *v16; // eax@77
  int v17; // ebx@78
  int v18; // eax@78
  int v19; // ecx@78
  int v20; // eax@80
  int v21; // ST1C_4@84
  __pid_t v22; // edi@84
  char *v23; // eax@84
  char *v24; // eax@85
  char *v25; // eax@86
  int v26; // ST1C_4@90
  __pid_t v27; // ebx@90
  char *v28; // eax@90
  char *v29; // eax@92
  char *v30; // eax@93
  const char *v31; // ebx@95
  char *v32; // eax@98
  int v33; // ecx@105
  int v34; // ST1C_4@105
  char *v35; // edi@105
  int v36; // esi@105
  char *v37; // eax@105
  char *v38; // eax@105
  int v39; // edx@105
  _UNKNOWN *v40; // ebx@106
  char *v41; // eax@106
  _UNKNOWN *v42; // ebx@108
  char *v43; // eax@108
  _UNKNOWN *v44; // ebx@110
  char *v45; // eax@110
  int v46; // ST1C_4@111
  int v47; // ebx@111
  char *v48; // eax@111
  int v49; // ebx@111
  char *v50; // eax@111
  int v51; // ebx@111
  char *v52; // eax@111
  int v53; // eax@111
  int v54; // ecx@111
  int v55; // ebx@111
  int v56; // ST1C_4@112
  char *v57; // eax@112
  int v58; // ST1C_4@113
  char *v59; // ebx@113
  char *v60; // eax@113
  char *v61; // ebx@113
  char *v62; // eax@113
  int v63; // eax@113
  int v64; // edx@113
  int v65; // ebx@113
  int v66; // ST1C_4@114
  char *v67; // eax@114
  int v68; // ST1C_4@116
  char *v69; // eax@116
  char *v70; // eax@118
  int result; // eax@120
  int v72; // esi@123
  int v73; // eax@123
  int v74; // [sp-Ch] [bp-88h]@10
  char *v75; // [sp-Ch] [bp-88h]@23
  const char *v76; // [sp-8h] [bp-84h]@23
  const char *v77; // [sp-8h] [bp-84h]@70
  const char *v78; // [sp-8h] [bp-84h]@79
  size_t v79; // [sp-4h] [bp-80h]@23
  int v80; // [sp-4h] [bp-80h]@70
  int v81; // [sp-4h] [bp-80h]@79
  char v82; // [sp+8h] [bp-74h]@6
  char *v83; // [sp+Ch] [bp-70h]@105
  char *v84; // [sp+10h] [bp-6Ch]@105
  int v85; // [sp+14h] [bp-68h]@105
  char *v86; // [sp+18h] [bp-64h]@105
  bool v87; // [sp+1Ch] [bp-60h]@1
  signed int v88; // [sp+20h] [bp-5Ch]@1
  char *v89; // [sp+20h] [bp-5Ch]@105
  char *v90; // [sp+2Ch] [bp-50h]@113
  int v91; // [sp+30h] [bp-4Ch]@113
  char *v92; // [sp+34h] [bp-48h]@113
  char *v93; // [sp+38h] [bp-44h]@113
  __int16 v94; // [sp+3Ch] [bp-40h]@80
  __int16 v95; // [sp+3Eh] [bp-3Eh]@80
  int v96; // [sp+40h] [bp-3Ch]@80
  int v97; // [sp+44h] [bp-38h]@80
  __pid_t pid; // [sp+48h] [bp-34h]@84
  char *v99; // [sp+4Ch] [bp-30h]@113
  char *v100; // [sp+50h] [bp-2Ch]@113
  int v101; // [sp+54h] [bp-28h]@113
  int v102; // [sp+58h] [bp-24h]@36
  int v103; // [sp+5Ch] [bp-20h]@36
  int v104; // [sp+60h] [bp-1Ch]@1

  v104 = 0;
  v3 = dcgettext(
         0,
         "\nMentoHUST\t: %s\nCopyright (C) 2009-2010 HustMoon Studio\n\nBug report to %s\n\n",
         5);
  __printf_chk(1, v3, "0.3.1", "http://code.google.com/p/mentohust/issues/list");
  v88 = 1;
  v4 = 0;
  v87 = sub_804CB6A((int)&v104) != 0;
  while ( 1 )
  {
    v9 = a2;
    if ( v88 >= a2 )
      goto LABEL_68;
    a1 = *(_DWORD *)(a3 + 4 * v88);
    if ( *(_BYTE *)a1 != 47 && *(_BYTE *)a1 != 45 )
      goto LABEL_66;
    v5 = *(_BYTE *)(a1 + 1);
    if ( v5 == 63 || v5 == 104 || (v82 = *(_BYTE *)(a1 + 1), !strcmp((const char *)a1, "--help")) )
    {
      v6 = *(_DWORD *)a3;
      v7 = dcgettext(
             0,
             ":\t%s [-][]\n:\t-h \n\t-k -k() ()\n\t-w \n\t-u \n\t-p \n\t-n \n\t-i IP[IP]\n\t-m []\n\t-g [0.0.0.0]\n\t-s DNS[0.0.0.0]\n\t-o Ping[0.0.0.0]\n\t-t ()[8]\n\t-e ()[30]\n\t-r ()[15]\n\t-l [08]\n\t-a : 0() 1() 2() [0]\n\t-d DHCP: 0() 1() 2() 3() [0]\n\t-b : 0() 1() 2() 3() [0]\n\t-y : 0() 1~20() [5]\n\t-v [0.00xrgsu]\n\t-f []\n\t-c DHCP[dhclient]\n\t-q SuConfig.dat(-q/path/SuConfig.dat)\n,
             5);
      __printf_chk(1, v7, v6, v6);
      goto LABEL_10;
    }
    if ( v82 == 113 )
    {
      sub_804B950((const char *)(a1 + 2));
LABEL_10:
      v74 = 0;
      goto LABEL_11;
    }
    if ( v82 == 119 )
    {
      v87 = 1;
      goto LABEL_66;
    }
    if ( v82 == 107 )
      break;
    if ( strlen((const char *)a1) <= 2 )
      goto LABEL_66;
    if ( v82 == 117 )
    {
      a1 += 2;
      v79 = 64;
      v76 = (const char *)a1;
      v75 = &byte_8051138;
LABEL_26:
      strncpy(v75, v76, v79);
      goto LABEL_66;
    }
    if ( v82 == 112 )
    {
      a1 += 2;
      v79 = 64;
      v76 = (const char *)a1;
      v75 = (char *)&stream;
      goto LABEL_26;
    }
    if ( v82 == 110 )
    {
      a1 += 2;
      v79 = 15;
      v76 = (const char *)a1;
      v75 = (char *)&stream._cur_column;
      goto LABEL_26;
    }
    if ( v82 == 102 )
    {
      a1 += 2;
      v79 = 254;
      v76 = (const char *)a1;
      v75 = (char *)&stream.__pad1;
      goto LABEL_26;
    }
    if ( v82 == 99 )
    {
      a1 += 2;
      v79 = 254;
      v76 = (const char *)a1;
      v75 = &domainname;
      goto LABEL_26;
    }
    switch ( v82 )
    {
      case 118:
        a1 += 2;
        if ( strlen((const char *)a1) > 2 && __isoc99_sscanf(a1, "%u.%u", &v102, &v103) != -1 )
        {
          if ( v102 )
          {
            LOBYTE(word_8051A50) = v102;
            dword_8051464 = 1;
            HIBYTE(word_8051A50) = v103;
          }
          else
          {
            dword_8051464 = 0;
          }
        }
        break;
      case 105:
        a1 += 2;
        dword_8051A00 = inet_addr((const char *)a1);
        break;
      case 109:
        a1 += 2;
        dword_8051A04 = inet_addr((const char *)a1);
        break;
      case 103:
        a1 += 2;
        dword_8051A08 = inet_addr((const char *)a1);
        break;
      case 115:
        a1 += 2;
        dword_8051A0C = inet_addr((const char *)a1);
        break;
      case 111:
        a1 += 2;
        dword_8051A10 = inet_addr((const char *)a1);
        break;
      case 116:
        a1 += 2;
        dword_80513D0 = atoi((const char *)a1) % 100;
        break;
      case 101:
        a1 += 2;
        dword_80513D4 = atoi((const char *)a1) % 1000;
        break;
      case 114:
        a1 += 2;
        dword_80513D8 = atoi((const char *)a1) % 100;
        break;
      case 97:
        a1 += 2;
        dword_8051A14 = atoi((const char *)a1) % 3;
        break;
      case 100:
        a1 += 2;
        dword_8051A18 = atoi((const char *)a1) % 4;
        break;
      case 121:
        a1 += 2;
        dword_8051134 = atoi((const char *)a1) % 21;
        break;
      case 98:
        a1 += 2;
        v104 = atoi((const char *)a1) % 4;
        break;
      case 108:
        a1 += 2;
        dword_80513DC = atoi((const char *)a1);
        break;
    }
LABEL_66:
    ++v88;
  }
  v8 = -1;
  v9 = a1;
  do
  {
    if ( !v8 )
      break;
    v10 = *(_BYTE *)v9++ == 0;
    --v8;
  }
  while ( !v10 );
  if ( (unsigned int)(~v8 - 1) > 2 )
  {
    v4 = 2;
    goto LABEL_66;
  }
  v4 = 1;
LABEL_68:
  if ( sub_804AAA4() == -1 )
  {
    v11 = dword_8051134;
    if ( dword_8051134 )
    {
      v80 = 5;
      v77 = "libpcap, ";
LABEL_123:
      v72 = (int)dcgettext(0, v77, v80);
      v73 = (int)dcgettext(0, "MentoHUST - ", 5);
      if ( sub_804A865(v73, v72, 1000 * v11) < 0 )
        dword_8051134 = 0;
    }
    goto LABEL_125;
  }
  if ( !LOBYTE(stream._cur_column) )
  {
    v87 = 1;
    if ( sub_804C5B1(a1) == -1 )
    {
      v11 = dword_8051134;
      if ( dword_8051134 )
      {
        v80 = 5;
        v77 = "";
        goto LABEL_123;
      }
LABEL_125:
      v74 = 1;
LABEL_11:
      exit(v74);
    }
  }
  if ( !byte_8051138 || !(_BYTE)stream._flags )
  {
    v12 = dcgettext(0, "?? : ", 5);
    __printf_chk(1, v12);
    __isoc99_scanf("%s", &byte_8051138);
    v13 = dcgettext(0, "?? : ", 5);
    __printf_chk(1, v13);
    sub_804C4D5((int)&stream);
    __printf_chk(1, "\n");
    v14 = dcgettext(0, "?? (0 1 2): ", 5);
    __printf_chk(1, v14);
    v9 = v15;
    __isoc99_scanf("%u", &dword_8051A14);
    dword_8051A14 %= 3u;
    v16 = dcgettext(0, "?? DHCP(0 1 2 3): ", 5);
    __printf_chk(1, v16);
    __isoc99_scanf("%u", &dword_8051A18);
    dword_8051A18 &= 3u;
    v87 = 1;
  }
  v17 = v104;
  v18 = open(off_804FCE8, 66, 420, v9);
  fd = v18;
  if ( v18 < 0 )
  {
    v81 = 5;
    v78 = "!! ";
    goto LABEL_98;
  }
  v96 = 0;
  v95 = 0;
  v97 = 0;
  v94 = 1;
  v20 = fcntl(v18, 5, &v94, v19);
  if ( v20 < 0 )
  {
    v81 = 5;
    v78 = "!! ";
    goto LABEL_98;
  }
  if ( v4 )
  {
    if ( v94 == 2 )
    {
      v25 = dcgettext(0, "!! MentoHUST\n", 5);
      __printf_chk(1, v25);
    }
    else
    {
      v21 = v20;
      v22 = pid;
      v23 = dcgettext(0, ">> MentoHUST(PID=%d).\n", 5);
      __printf_chk(1, v23, v22, v21);
      if ( kill(pid, 2) == -1 )
      {
        v24 = dcgettext(0, "!! ", 5);
        perror(v24);
      }
    }
    if ( v4 == 1 )
      goto LABEL_10;
  }
  else
  {
    if ( v94 != 2 )
    {
      v26 = v20;
      v27 = pid;
      v28 = dcgettext(0, "!! MentoHUST(PID=%d)!\n", 5);
      __printf_chk(1, v28, v27, v26);
      goto LABEL_125;
    }
  }
  if ( v17 )
  {
    v29 = dcgettext(0, ">> -k\n", 5);
    __printf_chk(1, v29);
    if ( daemon(0, (v17 + 1) % 2) )
    {
      v30 = dcgettext(0, "!! ", 5);
      perror(v30);
    }
    else
    {
      if ( v17 == 3 )
      {
        v31 = off_804FCEC;
        freopen(off_804FCEC, "w", stdout);
        setvbuf(stdout, 0, 1, 0x2000u);
        freopen(v31, "a", stderr);
      }
    }
  }
  v94 = 1;
  pid = getpid();
  if ( fcntl(fd, 7, &v94, pid) < 0 )
  {
    v81 = 5;
    v78 = "!! ";
LABEL_98:
    v32 = dcgettext(0, v78, v81);
    perror(v32);
    v11 = dword_8051134;
    if ( dword_8051134 )
    {
      v80 = 5;
      v77 = "root";
      goto LABEL_123;
    }
    goto LABEL_125;
  }
  if ( dword_8051A14 % 3u == 2 && !dword_8051A08 )
  {
    dword_8051A08 = dword_8051A00;
    BYTE3(dword_8051A08) = 2;
  }
  if ( !domainname )
    __strcpy_chk(&domainname, off_804FC50[0], 255);
  sub_804B28D();
  v34 = v33;
  v89 = dcgettext(0, "", 5);
  v35 = dcgettext(0, "", 5);
  v36 = (int)dcgettext(0, "", 5);
  v86 = dcgettext(0, "", 5);
  v85 = (int)dcgettext(0, "", 5);
  v84 = dcgettext(0, "", 5);
  v83 = dcgettext(0, "", 5);
  v37 = dcgettext(0, "** :\t%s\n", 5);
  __printf_chk(1, v37, &byte_8051138);
  v38 = dcgettext(0, "** : \t%s\n", 5);
  __printf_chk(1, v38, &stream._cur_column, v34);
  if ( dword_8051A08 )
  {
    v40 = sub_804B5AB(dword_8051A08);
    v41 = dcgettext(0, "** :\t%s\n", 5);
    __printf_chk(1, v41, v40);
  }
  if ( dword_8051A0C )
  {
    v42 = sub_804B5AB(dword_8051A0C);
    v43 = dcgettext(0, "** DNS:\t%s\n", 5);
    __printf_chk(1, v43, v42);
  }
  if ( dword_8051A10 )
  {
    v44 = sub_804B5AB(dword_8051A10);
    v45 = dcgettext(0, "** :\t%s\n", 5);
    __printf_chk(1, v45, v44);
  }
  v46 = v39;
  v47 = dword_80513D0;
  v48 = dcgettext(0, "** :\t%u\n", 5);
  __printf_chk(1, v48, v47);
  v49 = dword_80513D4;
  v50 = dcgettext(0, "** :\t%u\n", 5);
  __printf_chk(1, v50, v49);
  v51 = dword_80513D8;
  v52 = dcgettext(0, "** :\t%u\n", 5);
  v53 = __printf_chk(1, v52, v51, v46);
  v55 = dword_80513DC;
  if ( dword_80513DC )
  {
    v56 = v53;
    v57 = dcgettext(0, "** :\t%u\n", 5);
    __printf_chk(1, v57, v55, v56);
  }
  v58 = v54;
  v99 = v89;
  v100 = v35;
  v101 = v36;
  v59 = (&v99)[4 * dword_8051A14];
  v60 = dcgettext(0, "** :\t%s\n", 5);
  __printf_chk(1, v60, v59);
  v90 = v86;
  v92 = v84;
  v91 = v85;
  v93 = v83;
  v61 = (&v90)[4 * dword_8051A18];
  v62 = dcgettext(0, "** DHCP:\t%s\n", 5);
  v63 = __printf_chk(1, v62, v61, v58);
  v65 = dword_8051134;
  if ( dword_8051134 )
  {
    v66 = v64;
    v67 = dcgettext(0, "** :\t%d\n", 5);
    v63 = __printf_chk(1, v67, v65, v66);
  }
  if ( dword_8051464 > 1 )
  {
    v68 = v63;
    v69 = dcgettext(0, "** :\t%s\n", 5);
    __printf_chk(1, v69, &stream.__pad1, v68);
  }
  if ( dword_8051A18 )
  {
    v70 = dcgettext(0, "** DHCP:\t%s\n", 5);
    __printf_chk(1, v70, &domainname, v85);
  }
  if ( sub_804B5DF(v85, v36) == -1 || (result = sub_804C3BC() + 1) == 0 )
  {
    v11 = dword_8051134;
    if ( dword_8051134 )
    {
      v80 = 5;
      v77 = "MAC";
      goto LABEL_123;
    }
    goto LABEL_125;
  }
  if ( v87 )
    result = sub_804C890(v104);
  return result;
}
// 8048DAC: using guessed type int __isoc99_sscanf(_DWORD, const char *, ...);
// 8048DBC: using guessed type int __printf_chk(_DWORD, const char *, ...);
// 8048F7C: using guessed type int __cdecl __strcpy_chk(_DWORD, _DWORD, _DWORD);
// 804900C: using guessed type int __isoc99_scanf(const char *, ...);
// 804C3BC: using guessed type int sub_804C3BC(void);
// 804FC50: using guessed type char *off_804FC50[2];
// 8051134: using guessed type int dword_8051134;
// 80513D0: using guessed type int dword_80513D0;
// 80513D4: using guessed type int dword_80513D4;
// 80513D8: using guessed type int dword_80513D8;
// 80513DC: using guessed type int dword_80513DC;
// 8051464: using guessed type int dword_8051464;
// 8051A00: using guessed type int dword_8051A00;
// 8051A04: using guessed type int dword_8051A04;
// 8051A08: using guessed type int dword_8051A08;
// 8051A0C: using guessed type int dword_8051A0C;
// 8051A10: using guessed type int dword_8051A10;
// 8051A14: using guessed type int dword_8051A14;
// 8051A18: using guessed type int dword_8051A18;
// 8051A50: using guessed type __int16 word_8051A50;

//----- (0804DC40) --------------------------------------------------------
int __usercall sub_804DC40<eax>(int a1<ecx>, int *a2<ebx>, int a3<edi>, int a4)
{
  int result; // eax@2
  char *v5; // eax@3
  int v6; // ebx@3
  int v7; // esi@4
  int v8; // eax@4
  int v9; // [sp-10h] [bp-18h]@6

  if ( a4 != 14 )
  {
    dword_8051A40(status);
    v9 = 0;
    goto LABEL_8;
  }
  result = sub_804BBC1(a1, a2, a3, dword_805160C) + 1;
  if ( !result )
  {
    dword_8051A40(status);
    v5 = dcgettext(0, "!! , \n", 5);
    __printf_chk(1, v5);
    v6 = dword_8051134;
    if ( dword_8051134 )
    {
      v7 = (int)dcgettext(0, ", ", 5);
      v8 = (int)dcgettext(0, "MentoHUST - ", 5);
      if ( sub_804A865(v8, v7, 1000 * v6) < 0 )
        dword_8051134 = 0;
    }
    v9 = 1;
LABEL_8:
    exit(v9);
  }
  return result;
}
// 8051A40: invalid function type has been ignored
// 8048DBC: using guessed type int __printf_chk(_DWORD, const char *, ...);
// 8051134: using guessed type int dword_8051134;
// 805160C: using guessed type int dword_805160C;
// 8051A40: using guessed type int (__cdecl *dword_8051A40)(_DWORD);

//----- (0804DD0B) --------------------------------------------------------
void __usercall sub_804DD0B(int a1<eax>, unsigned int a2<edx>)
{
  int v2; // ebx@1
  unsigned __int8 v3; // cl@1
  char *v4; // edx@2
  int v5; // eax@2
  size_t v6; // esi@4
  signed int v7; // ecx@6
  char *v8; // edi@6
  char v9; // zf@8
  int v10; // ecx@9
  char *v11; // eax@12
  int v12; // esi@12
  char *v13; // eax@14
  int v14; // edi@14
  int v15; // eax@15
  int v16; // edx@18
  size_t v17; // eax@19
  char *v18; // ebx@21
  char *v19; // eax@26
  int v20; // ebx@26
  char *v21; // ST0C_4@28
  char *v22; // eax@28
  int v23; // esi@28
  int v24; // eax@29
  unsigned int v25; // [sp+Ch] [bp-1Ch]@1

  v2 = a1;
  v25 = a2;
  v3 = *(_BYTE *)(a1 + 27);
  if ( v3 )
  {
    v4 = (char *)(a1 + 28);
    v5 = 0;
    while ( 1 )
    {
      v6 = v3 - v5++;
      if ( *v4 != 10 )
      {
        if ( *v4 != 13 )
          break;
      }
      ++v4;
    }
    v7 = -1;
    v8 = v4;
    do
    {
      if ( !v7 )
        break;
      v9 = *v8++ == 0;
      --v7;
    }
    while ( !v9 );
    v10 = ~v7 - 1;
    if ( v10 < v6 )
      v6 = v10;
    if ( (signed int)v6 > 0 )
    {
      v11 = sub_804B8C6(v4, v6);
      v12 = (int)v11;
      if ( v11 )
      {
        if ( *v11 )
        {
          v13 = dcgettext(0, "$$ :\t%s\n", 5);
          __printf_chk(1, v13, v12, v8);
          v14 = dword_8051134;
          if ( dword_8051134 )
          {
            v15 = (int)dcgettext(0, "MentoHUST - ", 5);
            if ( sub_804A865(v15, v12, 1000 * v14) < 0 )
              dword_8051134 = 0;
          }
        }
        free((void *)v12);
      }
    }
  }
  v16 = *(_BYTE *)(v2 + 27) + 172;
  if ( v16 < v25 )
  {
    v17 = *(_BYTE *)(v2 + v16 - 1) - 2;
    if ( v17 > v25 - v16 )
      v17 = v25 - v16;
    v18 = (char *)(v16 + v2);
    while ( *v18 == 10 || *v18 == 13 )
    {
      ++v18;
      --v17;
    }
    if ( (signed int)v17 > 0 )
    {
      v19 = sub_804B8C6(v18, v17);
      v20 = (int)v19;
      if ( v19 )
      {
        if ( *v19 )
        {
          v21 = v19;
          v22 = dcgettext(0, "$$ :\t%s\n", 5);
          __printf_chk(1, v22, v20, v21);
          v23 = dword_8051134;
          if ( dword_8051134 )
          {
            v24 = (int)dcgettext(0, "MentoHUST - ", 5);
            if ( sub_804A865(v24, v20, 1000 * v23) < 0 )
              dword_8051134 = 0;
          }
        }
        free((void *)v20);
      }
    }
  }
}
// 8048DBC: using guessed type int __printf_chk(_DWORD, const char *, ...);
// 8051134: using guessed type int dword_8051134;

//----- (0804DE92) --------------------------------------------------------
int __fastcall sub_804DE92(int a1, int a2, int a3, int a4, int a5)
{
  int *v5; // ebx@1
  char v6; // dl@1
  int v7; // edi@3
  char v8; // al@5
  char v9; // dl@6
  char v10; // dl@7
  _UNKNOWN *v11; // esi@9
  char *v12; // eax@9
  char *v13; // eax@19
  int v14; // ST10_4@19
  unsigned int v15; // kr04_4@26
  unsigned __int16 v16; // dx@26
  size_t v17; // edx@26
  void *v18; // ebx@29
  int v19; // ST1C_4@30
  char *v20; // eax@30
  int v21; // esi@30
  int v22; // eax@31
  char *v23; // eax@39
  int v24; // ST14_4@39
  int *v25; // ST10_4@39
  char *v26; // eax@42
  signed int v27; // ecx@42
  int v28; // ebx@45
  signed int v29; // ST1C_4@46
  char *v30; // eax@46
  int v31; // edx@53
  int v32; // ST1C_4@55
  _UNKNOWN *v33; // ebx@55
  char *v34; // eax@55
  _UNKNOWN *v35; // eax@55
  int v36; // ebx@58
  int v37; // ST1C_4@59
  _UNKNOWN *v38; // esi@59
  char *v39; // eax@59
  _UNKNOWN *v40; // ebx@60
  char *v41; // eax@60
  int v42; // esi@60
  int v43; // eax@60
  int result; // eax@62
  signed int v45; // [sp-10h] [bp-68h]@13
  char command; // [sp+Ah] [bp-4Eh]@55
  int v47; // [sp+3Ch] [bp-1Ch]@1

  v5 = (int *)a5;
  v47 = *MK_FP(__GS__, 20);
  v6 = *(_BYTE *)(a5 + 12);
  if ( v6 != -120 || *(_BYTE *)(a5 + 13) != -114 )
  {
    if ( (_BYTE)dword_8051A54 != -2 )
    {
      if ( v6 == 8 )
      {
        if ( *(_BYTE *)(a5 + 13) == 6 )
        {
          v31 = *(_DWORD *)(a5 + 28);
          if ( v31 == dword_8051A08 )
          {
            if ( (_BYTE)dword_8051A54 == -1 )
            {
              dword_8051A54 = *(_DWORD *)(a5 + 22);
              v32 = v31;
              word_8051A58 = *(_WORD *)(a5 + 26);
              v33 = sub_804B3FF((int)&dword_8051A54, 6);
              v34 = dcgettext(0, "** MAC:\t%s\n", 5);
              __printf_chk(1, v34, v33, v32);
              sub_804B3FF((int)&dword_8051A54, 6);
              v35 = sub_804B5AB(dword_8051A08);
              __sprintf_chk(&command, 1, 50, "arp -s %s %s", v35);
              system(&command);
            }
            else
            {
              if ( *(_BYTE *)(a5 + 21) == 2 )
              {
                if ( !memcmp(&dword_8051468, (const void *)(a5 + 38), 4u) )
                {
                  v36 = a5 + 22;
                  if ( memcmp(&dword_8051A54, (const void *)(a5 + 22), 6u) )
                  {
                    v37 = a1;
                    v38 = sub_804B3FF(v36, 6);
                    v39 = dcgettext(0, "** ARP:\t%s\n", 5);
                    __printf_chk(1, v39, v38, v37);
                    if ( dword_8051134 )
                    {
                      v40 = sub_804B3FF(v36, 6);
                      v41 = dcgettext(0, ": %s", 5);
                      __sprintf_chk(&command, 1, 50, v41, v40);
                      v42 = 1000 * dword_8051134;
                      v43 = (int)dcgettext(0, "MentoHUST - ARP", 5);
                      if ( sub_804A865(v43, (int)&command, v42) < 0 )
                        dword_8051134 = 0;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    goto LABEL_62;
  }
  v7 = a5 + 6;
  if ( memcmp(&dword_8051A5C, (const void *)(a5 + 6), 6u) && (unsigned int)dword_8051A14 > 2 )
    goto LABEL_62;
  dword_8051610 = a5;
  v8 = *(_BYTE *)(a5 + 15);
  if ( v8 )
  {
    if ( v8 != 5 )
      goto LABEL_62;
    goto LABEL_35;
  }
  v9 = *(_BYTE *)(a5 + 18);
  if ( v9 != 1 )
  {
    if ( v9 != 3 )
    {
      if ( v9 != 4 )
        goto LABEL_62;
      if ( dword_805160C != 6 && dword_805160C != 4 )
      {
        if ( *(_BYTE *)(a5 + 27) || (a1 = 3, dword_8051A14 % 3u == 2) )
        {
          v26 = dcgettext(0, ">> !\n", 5);
          __printf_chk(1, v26);
          v27 = 3;
          if ( dword_8051A14 % 3u != 2 )
            sub_804DD0B(a5, *(_DWORD *)(a4 + 8));
          if ( dword_80513DC )
          {
            v28 = dword_80513DC;
            ++dword_8051A20;
            if ( dword_8051A20 >= (unsigned int)dword_80513DC )
            {
              v29 = v27;
              v30 = dcgettext(0, ">> %u\n", 5);
              __printf_chk(1, v30, v28, v29);
              exit(0);
            }
          }
          sub_804BB38();
          goto LABEL_62;
        }
      }
      else
      {
        v23 = dcgettext(0, ">> !\n", 5);
        v7 = v24;
        __printf_chk(1, v23);
        v5 = v25;
      }
      v45 = 1;
      goto LABEL_16;
    }
    v13 = dcgettext(0, ">> !\n", 5);
    v7 = v14;
    __printf_chk(1, v13);
    a1 = 3;
    dword_8051A20 = 0;
    if ( dword_8051A14 % 3u != 2 )
    {
      sub_804AD88(a5);
      sub_804DD0B(a5, *(_DWORD *)(a4 + 8));
    }
    if ( (unsigned int)(dword_8051A18 - 1) <= 1 )
    {
      v45 = 5;
      goto LABEL_16;
    }
    a1 = 3;
    if ( dword_8051A14 % 3u == 2 )
    {
      v45 = 6;
      goto LABEL_16;
    }
LABEL_35:
    v45 = 4;
    goto LABEL_16;
  }
  v10 = *(_BYTE *)(a5 + 22);
  if ( v10 == 1 )
  {
    if ( (unsigned int)dword_8051A14 <= 2 )
    {
      dword_8051A5C = *(_DWORD *)(a5 + 6);
      word_8051A60 = *(_WORD *)(a5 + 10);
      v11 = sub_804B3FF((int)&dword_8051A5C, 6);
      v12 = dcgettext(0, "** MAC:\t%s\n", 5);
      __printf_chk(1, v12, v11, a5 + 6);
      dword_8051A14 += 3;
    }
    if ( dword_8051A14 == 3 )
    {
      v5 = (int *)(a5 + 23);
      if ( !memcmp((const void *)(a5 + 23), "User name", 9u) )
        dword_8051A14 = 5;
    }
    v45 = 2;
    goto LABEL_16;
  }
  if ( v10 == 4 )
  {
    v45 = 3;
LABEL_16:
    sub_804BBC1(a1, v5, v7, v45);
    goto LABEL_62;
  }
  if ( *(_BYTE *)(a5 + 22) == 2 )
  {
    v15 = strlen((const char *)(a5 + 23)) + 1;
    v16 = __ROR__(*(_WORD *)(a5 + 20), 8);
    v17 = v16 - 5;
    a1 = v15 - 1;
    if ( v15 - 1 < v17 )
      v17 = v15 - 1;
    if ( (signed int)v17 > 0 )
    {
      v18 = sub_804B8C6((char *)(a5 + 23), v17);
      if ( v18 )
      {
        v19 = a1;
        v20 = dcgettext(0, "$$ :\t%s\n", 5);
        __printf_chk(1, v20, v18, v19);
        v21 = dword_8051134;
        if ( dword_8051134 )
        {
          v22 = (int)dcgettext(0, "MentoHUST - ", 5);
          if ( sub_804A865(v22, (int)v18, 1000 * v21) < 0 )
            dword_8051134 = 0;
        }
        free(v18);
      }
    }
  }
LABEL_62:
  result = *MK_FP(__GS__, 20) ^ v47;
  if ( *MK_FP(__GS__, 20) != v47 )
    __stack_chk_fail(a1);
  return result;
}
// 8048DBC: using guessed type int __printf_chk(_DWORD, const char *, ...);
// 8048FCC: using guessed type int __fastcall __stack_chk_fail(_DWORD);
// 804906C: using guessed type int __sprintf_chk(_DWORD, _DWORD, _DWORD, const char *, ...);
// 8051134: using guessed type int dword_8051134;
// 80513DC: using guessed type int dword_80513DC;
// 8051468: using guessed type int dword_8051468;
// 805160C: using guessed type int dword_805160C;
// 8051610: using guessed type int dword_8051610;
// 8051A08: using guessed type int dword_8051A08;
// 8051A14: using guessed type int dword_8051A14;
// 8051A18: using guessed type int dword_8051A18;
// 8051A20: using guessed type int dword_8051A20;
// 8051A54: using guessed type int dword_8051A54;
// 8051A58: using guessed type __int16 word_8051A58;
// 8051A5C: using guessed type int dword_8051A5C;
// 8051A60: using guessed type __int16 word_8051A60;

//----- (0804E38E) --------------------------------------------------------
int __usercall sub_804E38E<eax>(int a1<ecx>, int *a2<ebx>, int a3<edi>)
{
  char *v3; // eax@9

  if ( dword_805160C )
    sub_804BBC1(a1, a2, a3, 0);
  if ( status )
    dword_8051A2C(status);
  if ( dword_805145C )
    free((void *)dword_805145C);
  if ( fd >= 0 )
    close(fd);
  sub_804A800();
  sub_804AA78();
  v3 = dcgettext(0, ">> \n", 5);
  return __printf_chk(1, v3);
}
// 8051A2C: invalid function type has been ignored
// 8048DBC: using guessed type int __printf_chk(_DWORD, const char *, ...);
// 805160C: using guessed type int dword_805160C;
// 8051A2C: using guessed type int (__cdecl *dword_8051A2C)(_DWORD);

//----- (0804E420) --------------------------------------------------------
void __cdecl sub_804E420()
{
  ;
}

//----- (0804E430) --------------------------------------------------------
int *__cdecl sub_804E430()
{
  init_proc();
  return &dword_8050F00;
}
// 8050F00: using guessed type int dword_8050F00;

//----- (0804E48A) --------------------------------------------------------
void __cdecl sub_804E48A()
{
  ;
}

//----- (0804E490) --------------------------------------------------------
int __cdecl sub_804E490(int a1)
{
  _UNKNOWN *v1; // eax@1

  v1 = &unk_80510F0;
  if ( &unk_80510F0 )
    v1 = (_UNKNOWN *)unk_80510F0;
  return __cxa_atexit(a1, 0, v1);
}
// 8048D3C: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);

//----- (0804E4D0) --------------------------------------------------------
void (*__cdecl sub_804E4D0())(void)
{
  void (*result)(void); // eax@1
  int *v1; // ebx@2

  result = (void (*)(void))dword_8050F00;
  if ( dword_8050F00 != -1 )
  {
    v1 = &dword_8050F00;
    do
    {
      --v1;
      result();
      result = (void (*)(void))*v1;
    }
    while ( *v1 != -1 );
  }
  return result;
}
// 8050F00: using guessed type int dword_8050F00;

//----- (0804E4FC) --------------------------------------------------------
void __cdecl term_proc()
{
  sub_8049100();
}

#error "There were 3 decompilation failure(s) on 64 function(s)"
